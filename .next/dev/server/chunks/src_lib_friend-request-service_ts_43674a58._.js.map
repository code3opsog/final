{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/friend-request-service.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport interface CachedFriendRequest {\r\n    id: number;  // Roblox user ID\r\n    username: string;\r\n    displayName: string;\r\n    avatarUrl: string;\r\n    created: string | null;\r\n    isBanned: boolean;\r\n    isBot: boolean;\r\n    botScore: number;\r\n    botReason: string | null;\r\n    status: 'pending' | 'accepted' | 'declined' | 'blocked';\r\n}\r\n\r\nexport type RequestFilter = 'all' | 'bots' | 'safe';\r\n\r\n/**\r\n * Save friend requests to JSONB column (single row per account)\r\n * Merges new requests with existing cache, preserving processed statuses\r\n * Only adds truly new requests to avoid unnecessary database updates\r\n */\r\nexport async function saveFriendRequests(\r\n    accountId: string,\r\n    requests: Omit<CachedFriendRequest, 'status'>[]\r\n): Promise<boolean> {\r\n    // First, get existing cache to preserve already processed requests\r\n    const { data: existingData } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    const existingRequests = (existingData?.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Create a set of existing request IDs for quick lookup\r\n    const existingIds = new Set(existingRequests.map(r => r.id));\r\n\r\n    // Find truly new requests (not already in cache)\r\n    const newRequests = requests.filter(r => !existingIds.has(r.id));\r\n\r\n    // If no new requests, skip the update entirely\r\n    if (newRequests.length === 0) {\r\n        console.log(`[Friend Request Service] No new requests for account ${accountId}, skipping update`);\r\n        return true;\r\n    }\r\n\r\n    console.log(`[Friend Request Service] Found ${newRequests.length} new requests out of ${requests.length} total`);\r\n\r\n    // Add pending status to new requests only\r\n    const newRequestsWithStatus: CachedFriendRequest[] = newRequests.map(r => ({\r\n        ...r,\r\n        status: 'pending' as const\r\n    }));\r\n\r\n    // Merge: keep existing pending requests + add new ones\r\n    // Remove requests that are no longer in the friend request list (already removed by Roblox)\r\n    const currentIds = new Set(requests.map(r => r.id));\r\n    const stillPendingExisting = existingRequests.filter(r =>\r\n        r.status === 'pending' && currentIds.has(r.id)\r\n    );\r\n\r\n    const mergedRequests = [...stillPendingExisting, ...newRequestsWithStatus];\r\n\r\n    // Compute stats from merged data\r\n    const pendingRequests = mergedRequests.filter(r => r.status === 'pending');\r\n    const botsCount = pendingRequests.filter(r => r.isBot).length;\r\n    const safeCount = pendingRequests.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: mergedRequests,\r\n            cached_at: new Date().toISOString(),\r\n            cached_total: pendingRequests.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    if (error) {\r\n        console.error('Failed to save friend requests:', error);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Get cached friend requests with filter (from JSONB column)\r\n * Also filters out users who have been added to the blacklist since caching\r\n */\r\nexport async function getCachedRequests(\r\n    accountId: string,\r\n    filter: RequestFilter = 'all'\r\n): Promise<{\r\n    requests: CachedFriendRequest[];\r\n    cachedAt: string | null;\r\n    total: number;\r\n    bots: number;\r\n    safe: number;\r\n} | null> {\r\n    // Fetch cached requests and blacklist in parallel\r\n    const [accountResult, blacklistResult] = await Promise.all([\r\n        supabase\r\n            .from('roblox_accounts')\r\n            .select('cached_friend_requests, cached_at, cached_total, cached_bots, cached_safe')\r\n            .eq('id', accountId)\r\n            .single(),\r\n        supabase\r\n            .from('roblox_blacklist')\r\n            .select('username, roblox_user_id')\r\n    ]);\r\n\r\n    if (accountResult.error || !accountResult.data) {\r\n        console.error('Failed to get cached requests:', accountResult.error);\r\n        return null;\r\n    }\r\n\r\n    const data = accountResult.data;\r\n    let requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Create sets for both blacklisted usernames and user IDs for efficient lookup\r\n    const blacklistedUsernames = new Set<string>();\r\n    const blacklistedUserIds = new Set<number>();\r\n\r\n    (blacklistResult.data || []).forEach((b: { username: string; roblox_user_id: string | null }) => {\r\n        blacklistedUsernames.add(b.username.toLowerCase());\r\n        if (b.roblox_user_id) {\r\n            blacklistedUserIds.add(parseInt(b.roblox_user_id, 10));\r\n        }\r\n    });\r\n\r\n    // Helper to check if a user is blacklisted (by username OR user ID)\r\n    const isBlacklisted = (r: CachedFriendRequest) =>\r\n        blacklistedUsernames.has(r.username.toLowerCase()) || blacklistedUserIds.has(r.id);\r\n\r\n    // Filter to only pending requests AND exclude blacklisted users\r\n    requests = requests.filter(r =>\r\n        r.status === 'pending' &&\r\n        !isBlacklisted(r)\r\n    );\r\n\r\n    // Apply additional filter\r\n    if (filter === 'bots') {\r\n        requests = requests.filter(r => r.isBot);\r\n    } else if (filter === 'safe') {\r\n        requests = requests.filter(r => !r.isBot);\r\n    }\r\n\r\n    // Recalculate totals after filtering out blacklisted users\r\n    const allPendingNonBlacklisted = ((data.cached_friend_requests as CachedFriendRequest[]) || [])\r\n        .filter(r => r.status === 'pending' && !isBlacklisted(r));\r\n\r\n    const total = allPendingNonBlacklisted.length;\r\n    const bots = allPendingNonBlacklisted.filter(r => r.isBot).length;\r\n    const safe = allPendingNonBlacklisted.filter(r => !r.isBot).length;\r\n\r\n    return {\r\n        requests,\r\n        cachedAt: data.cached_at as string | null,\r\n        total,\r\n        bots,\r\n        safe\r\n    };\r\n}\r\n\r\n/**\r\n * Get just the stats without loading full data\r\n */\r\nexport async function getRequestStats(accountId: string): Promise<{\r\n    total: number;\r\n    bots: number;\r\n    safe: number;\r\n    cachedAt: string | null;\r\n} | null> {\r\n    const { data, error } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_total, cached_bots, cached_safe, cached_at')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (error || !data) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        total: (data.cached_total as number) || 0,\r\n        bots: (data.cached_bots as number) || 0,\r\n        safe: (data.cached_safe as number) || 0,\r\n        cachedAt: data.cached_at as string | null\r\n    };\r\n}\r\n\r\n/**\r\n * Update a single request's status in JSONB\r\n */\r\nexport async function updateRequestStatus(\r\n    accountId: string,\r\n    robloxUserId: string,\r\n    status: 'accepted' | 'declined' | 'blocked'\r\n): Promise<boolean> {\r\n    // Get current cache\r\n    const { data } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (!data) return false;\r\n\r\n    const requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Update status and remove from pending\r\n    const updated = requests.filter(r => r.id !== parseInt(robloxUserId));\r\n\r\n    // Recompute counts\r\n    const pending = updated.filter(r => r.status === 'pending');\r\n    const botsCount = pending.filter(r => r.isBot).length;\r\n    const safeCount = pending.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: updated,\r\n            cached_total: pending.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Bulk update status for multiple requests\r\n */\r\nexport async function bulkUpdateStatus(\r\n    accountId: string,\r\n    robloxUserIds: string[],\r\n    status: 'accepted' | 'declined' | 'blocked'\r\n): Promise<boolean> {\r\n    if (robloxUserIds.length === 0) return true;\r\n\r\n    const { data } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (!data) return false;\r\n\r\n    const requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n    const idsToRemove = new Set(robloxUserIds.map(id => parseInt(id)));\r\n\r\n    // Remove processed requests\r\n    const updated = requests.filter(r => !idsToRemove.has(r.id));\r\n\r\n    // Recompute counts\r\n    const pending = updated.filter(r => r.status === 'pending');\r\n    const botsCount = pending.filter(r => r.isBot).length;\r\n    const safeCount = pending.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: updated,\r\n            cached_total: pending.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Clear all cached requests\r\n */\r\nexport async function clearCache(accountId: string): Promise<boolean> {\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: [],\r\n            cached_at: null,\r\n            cached_total: 0,\r\n            cached_bots: 0,\r\n            cached_safe: 0\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Remove a single user from cache\r\n */\r\nexport async function removeFromCache(\r\n    accountId: string,\r\n    robloxUserId: number\r\n): Promise<boolean> {\r\n    return updateRequestStatus(accountId, String(robloxUserId), 'declined');\r\n}\r\n"],"names":[],"mappings":"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"}}]
}