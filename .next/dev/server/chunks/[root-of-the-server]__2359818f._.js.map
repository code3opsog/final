{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { supabase } from './supabase';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'fallback-secret');\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    discordId: string;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport async function createSession(userId: string, discordId: string, isAdmin: boolean, ip?: string, userAgent?: string) {\r\n    const token = await new SignJWT({ userId, discordId, isAdmin })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setExpirationTime('7d')\r\n        .sign(JWT_SECRET);\r\n\r\n    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n    await supabase.from('sessions').insert({\r\n        user_id: userId,\r\n        token,\r\n        ip,\r\n        user_agent: userAgent,\r\n        expires_at: expiresAt,\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function verifySession(token: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n\r\n        console.log('verifySession - JWT payload:', payload);\r\n\r\n        // Simple query without join\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('token', token)\r\n            .single();\r\n\r\n        if (sessionError) {\r\n            console.error('verifySession - Session query error:', sessionError);\r\n            return null;\r\n        }\r\n\r\n        if (!session || new Date(session.expires_at) < new Date()) {\r\n            console.log('verifySession - Session expired or not found');\r\n            return null;\r\n        }\r\n\r\n        // Get user separately\r\n        const { data: user, error: userError } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user_id)\r\n            .single();\r\n\r\n        if (userError || !user) {\r\n            console.error('verifySession - User query error:', userError);\r\n            return null;\r\n        }\r\n\r\n        console.log('verifySession - Success, user:', user.username);\r\n\r\n        return {\r\n            userId: session.user_id,\r\n            discordId: user.discord_id,\r\n            isAdmin: user.is_admin,\r\n        };\r\n    } catch (error) {\r\n        console.error('verifySession - JWT or other error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('session')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    const payload = await verifySession(token);\r\n    if (!payload) return null;\r\n\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', payload.userId)\r\n        .single();\r\n\r\n    return user;\r\n}\r\n\r\nexport async function isUserAuthorized(userId: string): Promise<boolean> {\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n    if (!user) return false;\r\n    if (user.is_admin) return true;\r\n    if (!user.is_authorized) return false;\r\n    if (user.auth_expiry && new Date(user.auth_expiry) < new Date()) return false;\r\n\r\n    return true;\r\n}\r\n\r\nexport function getDiscordOAuthUrl() {\r\n    const params = new URLSearchParams({\r\n        client_id: process.env.DISCORD_CLIENT_ID!,\r\n        redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        response_type: 'code',\r\n        scope: 'identify email',\r\n    });\r\n\r\n    return `https://discord.com/api/oauth2/authorize?${params.toString()}`;\r\n}\r\n\r\nexport async function exchangeCodeForToken(code: string) {\r\n    const response = await fetch('https://discord.com/api/oauth2/token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n        body: new URLSearchParams({\r\n            client_id: process.env.DISCORD_CLIENT_ID!,\r\n            client_secret: process.env.DISCORD_CLIENT_SECRET!,\r\n            grant_type: 'authorization_code',\r\n            code,\r\n            redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        }),\r\n    });\r\n\r\n    return response.json();\r\n}\r\n\r\nexport async function getDiscordUser(accessToken: string) {\r\n    const response = await fetch('https://discord.com/api/users/@me', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    });\r\n\r\n    return response.json();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/app/api/user/settings/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getCurrentUser } from '@/lib/auth';\r\nimport { supabase } from '@/lib/supabase';\r\n\r\ninterface UserSettings {\r\n    auto_filter_enabled: boolean;\r\n}\r\n\r\n// GET user settings\r\nexport async function GET() {\r\n    try {\r\n        const user = await getCurrentUser();\r\n\r\n        if (!user) {\r\n            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\r\n        }\r\n\r\n        // Return current settings (default values if not set)\r\n        return NextResponse.json({\r\n            auto_filter_enabled: user.auto_filter_enabled ?? false,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching settings:', error);\r\n        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n    }\r\n}\r\n\r\n// POST update user settings\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n\r\n        if (!user) {\r\n            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\r\n        }\r\n\r\n        const body: Partial<UserSettings> = await request.json();\r\n\r\n        // Update settings\r\n        const updates: Record<string, unknown> = {};\r\n\r\n        if (body.auto_filter_enabled !== undefined) {\r\n            updates.auto_filter_enabled = body.auto_filter_enabled;\r\n        }\r\n\r\n        if (Object.keys(updates).length > 0) {\r\n            const { error } = await supabase\r\n                .from('users')\r\n                .update(updates)\r\n                .eq('id', user.id);\r\n\r\n            if (error) {\r\n                console.error('Error updating settings:', error);\r\n                return NextResponse.json({ error: 'Failed to update settings' }, { status: 500 });\r\n            }\r\n        }\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            ...updates,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error updating settings:', error);\r\n        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAOO,eAAe;IAClB,IAAI;QACA,MAAM,OAAO,MAAM,IAAA,sIAAc;QAEjC,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,sDAAsD;QACtD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,qBAAqB,KAAK,mBAAmB,IAAI;QACrD;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ;AAGO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,OAAO,MAAM,IAAA,sIAAc;QAEjC,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,OAA8B,MAAM,QAAQ,IAAI;QAEtD,kBAAkB;QAClB,MAAM,UAAmC,CAAC;QAE1C,IAAI,KAAK,mBAAmB,KAAK,WAAW;YACxC,QAAQ,mBAAmB,GAAG,KAAK,mBAAmB;QAC1D;QAEA,IAAI,OAAO,IAAI,CAAC,SAAS,MAAM,GAAG,GAAG;YACjC,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CAC3B,IAAI,CAAC,SACL,MAAM,CAAC,SACP,EAAE,CAAC,MAAM,KAAK,EAAE;YAErB,IAAI,OAAO;gBACP,QAAQ,KAAK,CAAC,4BAA4B;gBAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAA4B,GAAG;oBAAE,QAAQ;gBAAI;YACnF;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,GAAG,OAAO;QACd;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}}]
}