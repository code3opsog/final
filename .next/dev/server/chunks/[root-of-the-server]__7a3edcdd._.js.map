{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { supabase } from './supabase';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'fallback-secret');\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    discordId: string;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport async function createSession(userId: string, discordId: string, isAdmin: boolean, ip?: string, userAgent?: string) {\r\n    const token = await new SignJWT({ userId, discordId, isAdmin })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setExpirationTime('7d')\r\n        .sign(JWT_SECRET);\r\n\r\n    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n    await supabase.from('sessions').insert({\r\n        user_id: userId,\r\n        token,\r\n        ip,\r\n        user_agent: userAgent,\r\n        expires_at: expiresAt,\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function verifySession(token: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n\r\n        console.log('verifySession - JWT payload:', payload);\r\n\r\n        // Simple query without join\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('token', token)\r\n            .single();\r\n\r\n        if (sessionError) {\r\n            console.error('verifySession - Session query error:', sessionError);\r\n            return null;\r\n        }\r\n\r\n        if (!session || new Date(session.expires_at) < new Date()) {\r\n            console.log('verifySession - Session expired or not found');\r\n            return null;\r\n        }\r\n\r\n        // Get user separately\r\n        const { data: user, error: userError } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user_id)\r\n            .single();\r\n\r\n        if (userError || !user) {\r\n            console.error('verifySession - User query error:', userError);\r\n            return null;\r\n        }\r\n\r\n        console.log('verifySession - Success, user:', user.username);\r\n\r\n        return {\r\n            userId: session.user_id,\r\n            discordId: user.discord_id,\r\n            isAdmin: user.is_admin,\r\n        };\r\n    } catch (error) {\r\n        console.error('verifySession - JWT or other error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('session')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    const payload = await verifySession(token);\r\n    if (!payload) return null;\r\n\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', payload.userId)\r\n        .single();\r\n\r\n    return user;\r\n}\r\n\r\nexport async function isUserAuthorized(userId: string): Promise<boolean> {\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n    if (!user) return false;\r\n    if (user.is_admin) return true;\r\n    if (!user.is_authorized) return false;\r\n    if (user.auth_expiry && new Date(user.auth_expiry) < new Date()) return false;\r\n\r\n    return true;\r\n}\r\n\r\nexport function getDiscordOAuthUrl() {\r\n    const params = new URLSearchParams({\r\n        client_id: process.env.DISCORD_CLIENT_ID!,\r\n        redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        response_type: 'code',\r\n        scope: 'identify email',\r\n    });\r\n\r\n    return `https://discord.com/api/oauth2/authorize?${params.toString()}`;\r\n}\r\n\r\nexport async function exchangeCodeForToken(code: string) {\r\n    const response = await fetch('https://discord.com/api/oauth2/token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n        body: new URLSearchParams({\r\n            client_id: process.env.DISCORD_CLIENT_ID!,\r\n            client_secret: process.env.DISCORD_CLIENT_SECRET!,\r\n            grant_type: 'authorization_code',\r\n            code,\r\n            redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        }),\r\n    });\r\n\r\n    return response.json();\r\n}\r\n\r\nexport async function getDiscordUser(accessToken: string) {\r\n    const response = await fetch('https://discord.com/api/users/@me', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    });\r\n\r\n    return response.json();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/rate-limiter.ts"],"sourcesContent":["// Advanced Rate Limiter Utility\r\n// Implements: Throttling, Exponential Backoff, Jitter, Batch Processing\r\n\r\n/**\r\n * Sleep for a given number of milliseconds\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Add random jitter to a delay to avoid detection patterns\r\n * @param baseDelay - Base delay in ms\r\n * @param jitterPercent - Jitter percentage (0-1), default 0.3 (30%)\r\n */\r\nexport function addJitter(baseDelay: number, jitterPercent: number = 0.3): number {\r\n    const jitter = baseDelay * jitterPercent * (Math.random() * 2 - 1);\r\n    return Math.max(0, baseDelay + jitter);\r\n}\r\n\r\n/**\r\n * Calculate exponential backoff delay\r\n * @param attempt - Current attempt number (0-indexed)\r\n * @param baseDelay - Base delay in ms, default 1000\r\n * @param maxDelay - Maximum delay in ms, default 30000\r\n */\r\nexport function exponentialBackoff(attempt: number, baseDelay: number = 1000, maxDelay: number = 30000): number {\r\n    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\r\n    return addJitter(delay);\r\n}\r\n\r\ninterface RetryOptions {\r\n    maxRetries?: number;\r\n    baseDelay?: number;\r\n    maxDelay?: number;\r\n    onRetry?: (attempt: number, error: Error, delay: number) => void;\r\n}\r\n\r\n/**\r\n * Execute a function with retry and exponential backoff\r\n */\r\nexport async function withRetry<T>(\r\n    fn: () => Promise<T>,\r\n    options: RetryOptions = {}\r\n): Promise<T> {\r\n    const {\r\n        maxRetries = 3,\r\n        baseDelay = 1000,\r\n        maxDelay = 30000,\r\n        onRetry\r\n    } = options;\r\n\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n        try {\r\n            return await fn();\r\n        } catch (error) {\r\n            lastError = error as Error;\r\n\r\n            // Check if it's a rate limit error (429)\r\n            const isRateLimit = error instanceof Error &&\r\n                (error.message.includes('429') || error.message.includes('rate limit'));\r\n\r\n            if (attempt < maxRetries) {\r\n                const delay = isRateLimit\r\n                    ? exponentialBackoff(attempt, baseDelay * 2, maxDelay) // Longer delay for rate limits\r\n                    : exponentialBackoff(attempt, baseDelay, maxDelay);\r\n\r\n                if (onRetry) {\r\n                    onRetry(attempt + 1, lastError, delay);\r\n                }\r\n\r\n                console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms...`);\r\n                await sleep(delay);\r\n            }\r\n        }\r\n    }\r\n\r\n    throw lastError;\r\n}\r\n\r\ninterface ThrottleOptions {\r\n    minDelay?: number;      // Minimum delay between requests (ms)\r\n    maxDelay?: number;      // Maximum delay for backoff (ms)\r\n    requestsPerSecond?: number;  // Target requests per second\r\n}\r\n\r\n/**\r\n * Creates a throttled request queue that respects rate limits\r\n */\r\nexport function createThrottledQueue(options: ThrottleOptions = {}) {\r\n    const {\r\n        minDelay = 100,\r\n        maxDelay = 5000,\r\n        requestsPerSecond = 5\r\n    } = options;\r\n\r\n    const delayPerRequest = 1000 / requestsPerSecond;\r\n    let lastRequestTime = 0;\r\n    let consecutiveErrors = 0;\r\n    let currentDelay = Math.max(minDelay, delayPerRequest);\r\n\r\n    return {\r\n        /**\r\n         * Execute a request with throttling\r\n         */\r\n        async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n            // Calculate time since last request\r\n            const now = Date.now();\r\n            const timeSinceLastRequest = now - lastRequestTime;\r\n\r\n            // Wait if needed\r\n            if (timeSinceLastRequest < currentDelay) {\r\n                await sleep(currentDelay - timeSinceLastRequest + addJitter(50));\r\n            }\r\n\r\n            lastRequestTime = Date.now();\r\n\r\n            try {\r\n                const result = await fn();\r\n\r\n                // Success - gradually reduce delay\r\n                consecutiveErrors = 0;\r\n                currentDelay = Math.max(minDelay, currentDelay * 0.9);\r\n\r\n                return result;\r\n            } catch (error) {\r\n                consecutiveErrors++;\r\n\r\n                // Increase delay on errors\r\n                currentDelay = Math.min(maxDelay, currentDelay * 2);\r\n\r\n                throw error;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Get current delay for monitoring\r\n         */\r\n        getCurrentDelay(): number {\r\n            return currentDelay;\r\n        },\r\n\r\n        /**\r\n         * Reset the queue state\r\n         */\r\n        reset(): void {\r\n            consecutiveErrors = 0;\r\n            currentDelay = Math.max(minDelay, delayPerRequest);\r\n            lastRequestTime = 0;\r\n        }\r\n    };\r\n}\r\n\r\ninterface BatchOptions<T, R> {\r\n    items: T[];\r\n    batchSize?: number;\r\n    delayBetweenBatches?: number;\r\n    onProgress?: (completed: number, total: number) => void;\r\n    processor: (item: T) => Promise<R>;\r\n}\r\n\r\n/**\r\n * Process items in batches with delays\r\n */\r\nexport async function processBatch<T, R>(options: BatchOptions<T, R>): Promise<R[]> {\r\n    const {\r\n        items,\r\n        batchSize = 10,\r\n        delayBetweenBatches = 2000,\r\n        onProgress,\r\n        processor\r\n    } = options;\r\n\r\n    const results: R[] = [];\r\n    const total = items.length;\r\n    let completed = 0;\r\n\r\n    // Split into batches\r\n    for (let i = 0; i < items.length; i += batchSize) {\r\n        const batch = items.slice(i, i + batchSize);\r\n\r\n        // Process batch concurrently\r\n        const batchResults = await Promise.all(\r\n            batch.map(async (item) => {\r\n                try {\r\n                    const result = await processor(item);\r\n                    completed++;\r\n\r\n                    if (onProgress) {\r\n                        onProgress(completed, total);\r\n                    }\r\n\r\n                    return result;\r\n                } catch (error) {\r\n                    completed++;\r\n                    console.error('Batch item failed:', error);\r\n                    return null as R;\r\n                }\r\n            })\r\n        );\r\n\r\n        results.push(...batchResults);\r\n\r\n        // Delay between batches (except for the last one)\r\n        if (i + batchSize < items.length) {\r\n            console.log(`Batch ${Math.floor(i / batchSize) + 1} complete. Waiting ${delayBetweenBatches}ms...`);\r\n            await sleep(addJitter(delayBetweenBatches));\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * Sequential processing with delay between each item\r\n * Better for strict rate limits\r\n */\r\nexport async function processSequentially<T, R>(\r\n    items: T[],\r\n    processor: (item: T) => Promise<R>,\r\n    delayBetweenItems: number = 200,\r\n    onProgress?: (completed: number, total: number) => void\r\n): Promise<R[]> {\r\n    const results: R[] = [];\r\n    const total = items.length;\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n        try {\r\n            const result = await processor(items[i]);\r\n            results.push(result);\r\n        } catch (error) {\r\n            console.error(`Item ${i} failed:`, error);\r\n            results.push(null as R);\r\n        }\r\n\r\n        if (onProgress) {\r\n            onProgress(i + 1, total);\r\n        }\r\n\r\n        // Delay between items (except for the last one)\r\n        if (i < items.length - 1) {\r\n            await sleep(addJitter(delayBetweenItems));\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/fingerprint.ts"],"sourcesContent":["// Request Fingerprint Spoofing\r\n// Makes each request look like it's from a different person/device\r\n\r\n// Realistic User-Agent strings from different devices/browsers\r\nconst USER_AGENTS = [\r\n    // Chrome Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',\r\n    // Firefox Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0',\r\n    // Chrome Mac\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',\r\n    // Safari Mac\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',\r\n    // Edge Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',\r\n    // Chrome Linux\r\n    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    // Mobile Chrome Android\r\n    'Mozilla/5.0 (Linux; Android 14; SM-S918B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.144 Mobile Safari/537.36',\r\n    'Mozilla/5.0 (Linux; Android 13; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.144 Mobile Safari/537.36',\r\n    // Mobile Safari iPhone\r\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',\r\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1',\r\n    // iPad\r\n    'Mozilla/5.0 (iPad; CPU OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',\r\n];\r\n\r\n// Accept-Language headers from different countries\r\nconst ACCEPT_LANGUAGES = [\r\n    'en-US,en;q=0.9',\r\n    'en-GB,en;q=0.9',\r\n    'en-US,en;q=0.9,es;q=0.8',\r\n    'en-US,en;q=0.9,fr;q=0.8',\r\n    'tr-TR,tr;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'es-ES,es;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'pl-PL,pl;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'nl-NL,nl;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7',\r\n];\r\n\r\n// Accept header variations\r\nconst ACCEPT_HEADERS = [\r\n    'application/json, text/plain, */*',\r\n    'application/json',\r\n    '*/*',\r\n    'application/json, text/javascript, */*; q=0.01',\r\n];\r\n\r\n// Sec-Fetch headers (modern browsers)\r\nconst SEC_FETCH_MODES = ['cors', 'no-cors', 'navigate'];\r\nconst SEC_FETCH_SITES = ['cross-site', 'same-origin', 'same-site', 'none'];\r\nconst SEC_FETCH_DESTS = ['document', 'empty', 'script'];\r\n\r\n// Cache-Control variations\r\nconst CACHE_CONTROLS = [\r\n    'no-cache',\r\n    'max-age=0',\r\n    'no-store',\r\n    undefined, // Some requests don't have this header\r\n];\r\n\r\n// Connection header variations\r\nconst CONNECTIONS = ['keep-alive', undefined];\r\n\r\n// Referer URLs (Roblox-related)\r\nconst REFERERS = [\r\n    'https://www.roblox.com/',\r\n    'https://www.roblox.com/users/profile',\r\n    'https://www.roblox.com/games',\r\n    'https://www.roblox.com/discover',\r\n    'https://www.roblox.com/home',\r\n    undefined, // Some requests don't have referer\r\n];\r\n\r\n/**\r\n * Get a random element from an array\r\n */\r\nfunction randomFrom<T>(arr: T[]): T {\r\n    return arr[Math.floor(Math.random() * arr.length)];\r\n}\r\n\r\n/**\r\n * Generate random fingerprint headers to mimic a real user\r\n */\r\nexport function generateRandomHeaders(): Record<string, string> {\r\n    const headers: Record<string, string> = {};\r\n\r\n    // Core headers - always include\r\n    headers['User-Agent'] = randomFrom(USER_AGENTS);\r\n    headers['Accept-Language'] = randomFrom(ACCEPT_LANGUAGES);\r\n    headers['Accept'] = randomFrom(ACCEPT_HEADERS);\r\n\r\n    // Optional headers - include randomly\r\n    const cacheControl = randomFrom(CACHE_CONTROLS);\r\n    if (cacheControl) {\r\n        headers['Cache-Control'] = cacheControl;\r\n    }\r\n\r\n    const connection = randomFrom(CONNECTIONS);\r\n    if (connection) {\r\n        headers['Connection'] = connection;\r\n    }\r\n\r\n    const referer = randomFrom(REFERERS);\r\n    if (referer) {\r\n        headers['Referer'] = referer;\r\n    }\r\n\r\n    // Sec-Fetch headers (50% chance to include - not all browsers send these)\r\n    if (Math.random() > 0.5) {\r\n        headers['Sec-Fetch-Mode'] = randomFrom(SEC_FETCH_MODES);\r\n        headers['Sec-Fetch-Site'] = randomFrom(SEC_FETCH_SITES);\r\n        headers['Sec-Fetch-Dest'] = randomFrom(SEC_FETCH_DESTS);\r\n    }\r\n\r\n    // DNT (Do Not Track) - random\r\n    if (Math.random() > 0.7) {\r\n        headers['DNT'] = '1';\r\n    }\r\n\r\n    // Upgrade-Insecure-Requests - random (usually for navigation)\r\n    if (Math.random() > 0.8) {\r\n        headers['Upgrade-Insecure-Requests'] = '1';\r\n    }\r\n\r\n    return headers;\r\n}\r\n\r\n/**\r\n * Generate random delay with human-like variation\r\n * Humans don't click at exact intervals - there's natural variation\r\n */\r\nexport function getHumanLikeDelay(baseDelay: number = 500): number {\r\n    // Add random jitter: 70-130% of base delay\r\n    const jitterMultiplier = 0.7 + (Math.random() * 0.6);\r\n    const delay = Math.round(baseDelay * jitterMultiplier);\r\n\r\n    // Occasionally add longer pause (like a human reading)\r\n    if (Math.random() > 0.9) {\r\n        return delay + Math.round(Math.random() * 2000); // Extra 0-2 seconds\r\n    }\r\n\r\n    return delay;\r\n}\r\n\r\n/**\r\n * Generate a unique request ID (some APIs track this)\r\n */\r\nexport function generateRequestId(): string {\r\n    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\r\n    let id = '';\r\n    for (let i = 0; i < 32; i++) {\r\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return id;\r\n}\r\n\r\n/**\r\n * Get current timestamp with slight randomization\r\n * (Some fingerprinting tracks exact request timing)\r\n */\r\nexport function getRandomizedTimestamp(): number {\r\n    return Date.now() + Math.floor(Math.random() * 1000) - 500;\r\n}\r\n\r\n/**\r\n * Generate a browser tracker ID (required by some Roblox API endpoints)\r\n * Format: Large numeric value that Roblox uses to track browser sessions\r\n * Example: 65445383610\r\n */\r\nexport function generateBrowserTrackerId(): string {\r\n    // Generate a large random number (10-12 digits like real Roblox tracker IDs)\r\n    const min = 10000000000; // 10 billion\r\n    const max = 99999999999; // ~100 billion\r\n    return String(Math.floor(Math.random() * (max - min) + min));\r\n}\r\n\r\n/**\r\n * Generate Roblox-specific headers that match what a real browser sends\r\n * Based on actual captured request from Chrome 143 (February 2026)\r\n * These headers closely match the format seen in real blocking requests\r\n */\r\nexport function generateRobloxHeaders(): Record<string, string> {\r\n    const browserTrackerId = generateBrowserTrackerId();\r\n    const acceptLanguage = randomFrom(ACCEPT_LANGUAGES);\r\n\r\n    return {\r\n        'Accept': 'application/json, text/plain, */*',\r\n        'Accept-Encoding': 'gzip, deflate, br',\r\n        'Accept-Language': acceptLanguage,\r\n        'Origin': 'https://www.roblox.com',\r\n        'Referer': 'https://www.roblox.com/',\r\n        'Priority': 'u=1, i',\r\n        'Sec-Ch-Ua': '\"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"',\r\n        'Sec-Ch-Ua-Mobile': '?0',\r\n        'Sec-Ch-Ua-Platform': '\"Windows\"',\r\n        'Sec-Fetch-Dest': 'empty',\r\n        'Sec-Fetch-Mode': 'cors',\r\n        'Sec-Fetch-Site': 'same-site',\r\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',\r\n        'x-browser-tracker-id': browserTrackerId,\r\n    };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/roblox.ts"],"sourcesContent":["// Roblox API client for friend request operations\r\n// With fingerprint spoofing for undetected requests and HBA token generation\r\nimport { HttpsProxyAgent } from 'https-proxy-agent';\r\nimport { HBAClient } from 'roblox-bat';\r\nimport { withRetry, sleep, addJitter } from './rate-limiter';\r\nimport { generateRandomHeaders, getHumanLikeDelay, generateBrowserTrackerId, generateRobloxHeaders } from './fingerprint';\r\n\r\ninterface RobloxUser {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n    created: string;\r\n    isBanned: boolean;\r\n}\r\n\r\ninterface FriendRequest {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n    created: string;\r\n}\r\n\r\n// Helper to create fetch options with optional HTTP proxy and fingerprint spoofing\r\nfunction getFetchOptions(customHeaders: Record<string, string>, httpProxy?: string, spoof: boolean = false): RequestInit {\r\n    // Start with random fingerprint headers if spoofing is enabled\r\n    const headers: Record<string, string> = spoof ? { ...generateRandomHeaders() } : {};\r\n\r\n    // Add custom headers (these override fingerprint headers if needed)\r\n    Object.assign(headers, customHeaders);\r\n\r\n    const options: RequestInit = { headers };\r\n\r\n    if (httpProxy) {\r\n        // @ts-ignore - agent is valid for node-fetch\r\n        options.agent = new HttpsProxyAgent(httpProxy);\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n// Use direct Roblox API instead of roproxy when using HTTP proxy\r\n// This is more \"undetected\" because roproxy itself might be flagged\r\nfunction getApiUrl(service: string, path: string, useDirectApi: boolean = false): string {\r\n    if (useDirectApi) {\r\n        // Direct Roblox API\r\n        return `https://${service}.roblox.com${path}`;\r\n    }\r\n    // roproxy (fallback for when no HTTP proxy is provided)\r\n    return `https://${service}.roproxy.com${path}`;\r\n}\r\n\r\n// Delay between paginated requests\r\nconst PAGE_DELAY_MS = 500;\r\n\r\nexport async function getFriendRequests(cookie: string, httpProxy?: string): Promise<FriendRequest[]> {\r\n    const allRequests: FriendRequest[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 10; // Safety limit: 10 pages * 100 = 1000 max requests\r\n    const useDirectApi = !!httpProxy; // Use direct API if proxy is available\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', '/v1/my/friends/requests', useDirectApi)}?limit=100&sortOrder=Desc&cursor=${cursor}`\r\n            : `${getApiUrl('friends', '/v1/my/friends/requests', useDirectApi)}?limit=100&sortOrder=Desc`;\r\n\r\n        console.log(`Fetching friend requests page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        // Use retry logic for each page\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch friend requests: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const requests = data.data || [];\r\n        allRequests.push(...requests);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${requests.length} requests, total: ${allRequests.length}`);\r\n\r\n        // Add human-like delay between pages\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allRequests.length} total friend requests`);\r\n    return allRequests;\r\n}\r\n\r\n// Delay between getUserInfo calls - minimal with fingerprint spoofing\r\nconst USER_INFO_DELAY_MS = 100;\r\nlet lastUserInfoCall = 0;\r\n\r\nexport async function getUserInfo(userId: number, httpProxy?: string): Promise<RobloxUser | null> {\r\n    // Throttle getUserInfo calls with human-like timing\r\n    const now = Date.now();\r\n    const timeSinceLastCall = now - lastUserInfoCall;\r\n    const requiredDelay = getHumanLikeDelay(USER_INFO_DELAY_MS);\r\n\r\n    if (timeSinceLastCall < requiredDelay) {\r\n        await sleep(requiredDelay - timeSinceLastCall);\r\n    }\r\n    lastUserInfoCall = Date.now();\r\n\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({}, httpProxy, true); // Enable spoofing\r\n\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(\r\n                getApiUrl('users', `/v1/users/${userId}`, useDirectApi),\r\n                options\r\n            );\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                console.log('getUserInfo failed for userId:', userId, 'status:', response.status);\r\n                return null;\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 2,\r\n            baseDelay: 1000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`getUserInfo(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error fetching user info:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCSRFToken(cookie: string, httpProxy?: string): Promise<string | null> {\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        const response = await fetch(getApiUrl('auth', '/v2/logout', useDirectApi), {\r\n            ...options,\r\n            method: 'POST',\r\n        });\r\n\r\n        return response.headers.get('x-csrf-token');\r\n    } catch (error) {\r\n        console.error('Error getting CSRF token:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function acceptFriendRequest(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/accept-friend-request`, useDirectApi);\r\n    console.log(`Accepting friend request for user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true); // Enable spoofing\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Accept failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully accepted friend request from ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Accept(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error accepting friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function declineFriendRequest(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/decline-friend-request`, useDirectApi);\r\n    console.log(`Declining friend request for user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true); // Enable spoofing\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Decline failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully declined friend request from ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Decline(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error declining friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\n/**\r\n * Decline ALL pending friend requests at once using Roblox's native bulk endpoint\r\n * This is much faster than declining one by one\r\n */\r\nexport async function declineAllFriendRequests(cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', '/v1/user/friend-requests/decline-all', useDirectApi);\r\n    console.log(`Declining ALL friend requests... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Decline-all failed: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log('Successfully declined ALL friend requests');\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Decline-all retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error declining all friend requests:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function blockUser(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    // Use direct Roblox API when proxy is available, otherwise fall back to roproxy\r\n    const useDirectApi = !!httpProxy;\r\n    const baseHost = useDirectApi ? 'apis.roblox.com' : 'apis.roproxy.com';\r\n    const url = `https://${baseHost}/user-blocking-api/v1/users/${userId}/block-user`;\r\n\r\n    console.log(`Blocking user ${userId}... (${useDirectApi ? 'DIRECT API via proxy' : 'roproxy'})`);\r\n\r\n    // Generate Roblox-specific headers\r\n    const robloxHeaders = generateRobloxHeaders();\r\n    const acceptLanguage = robloxHeaders['Accept-Language'];\r\n    const userAgent = robloxHeaders['User-Agent'];\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            // Step 1: Generate HBA token using roblox-bat library\r\n            // This creates proper ECDSA P-256 signed tokens\r\n            let hbaHeaders: Record<string, string> = {};\r\n\r\n            try {\r\n                // Generate a fresh key pair for this session\r\n                const keys = await crypto.subtle.generateKey(\r\n                    { name: 'ECDSA', namedCurve: 'P-256' },\r\n                    false,\r\n                    ['sign']\r\n                );\r\n\r\n                const hbaClient = new HBAClient({\r\n                    keys,\r\n                    cookie: `.ROBLOSECURITY=${cookie}`,\r\n                });\r\n\r\n                // Generate the x-bound-auth-token for this request\r\n                // The blocking API uses POST with empty body\r\n                hbaHeaders = await hbaClient.generateBaseHeaders(\r\n                    `https://apis.roblox.com/user-blocking-api/v1/users/${userId}/block-user`,\r\n                    'POST',\r\n                    true, // authenticated\r\n                    ''    // empty body\r\n                );\r\n\r\n                console.log(`HBA token generated for user ${userId}`);\r\n            } catch (hbaError) {\r\n                console.warn(`HBA token generation failed: ${hbaError}, continuing without it`);\r\n            }\r\n\r\n            // Step 2: Send POST request with all headers\r\n            // Generate a browser tracker ID for the request\r\n            const browserTrackerId = generateBrowserTrackerId();\r\n\r\n            // Build full cookie string with tracking cookies\r\n            // The browserid in RBXEventTrackerV2 must match x-browser-tracker-id\r\n            const now = new Date();\r\n            const createDate = `${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')}/${now.getFullYear()} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;\r\n            const sessionId = crypto.randomUUID();\r\n            const rbxId = Math.floor(Math.random() * 9000000000) + 1000000000; // Random 10-digit number\r\n\r\n            const fullCookie = [\r\n                `RBXSessionTracker=sessionid=${sessionId}`,\r\n                `RBXEventTrackerV2=CreateDate=${encodeURIComponent(createDate)}&rbxid=${rbxId}&browserid=${browserTrackerId}`,\r\n                `.ROBLOSECURITY=${cookie}`,\r\n            ].join('; ');\r\n\r\n            const postOptions = getFetchOptions({\r\n                'Content-Length': '0',\r\n                'Sec-Ch-Ua-Platform': '\"Windows\"',\r\n                'X-CSRF-TOKEN': csrfToken,\r\n                'Accept-Language': acceptLanguage,\r\n                'Sec-Ch-Ua': '\"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"',\r\n                'Sec-Ch-Ua-Mobile': '?0',\r\n                'x-browser-tracker-id': browserTrackerId,\r\n                ...hbaHeaders, // Adds x-bound-auth-token if generated\r\n                'Accept': 'application/json, text/plain, */*',\r\n                'User-Agent': userAgent,\r\n                'Origin': 'https://www.roblox.com',\r\n                'Sec-Fetch-Site': 'same-site',\r\n                'Sec-Fetch-Mode': 'cors',\r\n                'Sec-Fetch-Dest': 'empty',\r\n                'Referer': 'https://www.roblox.com/',\r\n                'Accept-Encoding': 'gzip, deflate, br',\r\n                'Priority': 'u=1, i',\r\n                'Cookie': fullCookie,\r\n            }, httpProxy, false);\r\n\r\n            const response = await fetch(url, {\r\n                ...postOptions,\r\n                method: 'POST',\r\n                body: '',\r\n            });\r\n\r\n            console.log(`Block response for ${userId}: status=${response.status} (proxy: ${httpProxy ? 'yes' : 'no'})`);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            let responseBody: string | null = null;\r\n            try {\r\n                responseBody = await response.text();\r\n            } catch {\r\n                responseBody = null;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                console.error(`Block failed for ${userId}: HTTP ${response.status}`);\r\n                console.error(`Response body: ${responseBody || '(empty)'}`);\r\n\r\n                if (responseBody) {\r\n                    try {\r\n                        const errorData = JSON.parse(responseBody);\r\n                        if (errorData.errors?.[0]?.message) {\r\n                            return { success: false, error: errorData.errors[0].message };\r\n                        }\r\n                    } catch {\r\n                        // Not JSON\r\n                    }\r\n                }\r\n\r\n                return { success: false, error: `HTTP ${response.status}: ${responseBody || 'Unknown error'}` };\r\n            }\r\n\r\n            console.log(`Successfully blocked user ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 2,\r\n            baseDelay: 3000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Block(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error blocking user:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function unfriendUser(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/unfriend`, useDirectApi);\r\n    console.log(`Unfriending user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Unfriend failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully unfriended user ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Unfriend(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error unfriending user:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\ninterface Friend {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n}\r\n\r\nexport async function getFriends(cookie: string, httpProxy?: string): Promise<Friend[]> {\r\n    const allFriends: Friend[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 20; // Safety limit: 20 pages * 100 = 2000 max friends\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', '/v1/my/friends', useDirectApi)}?limit=100&cursor=${cursor}`\r\n            : `${getApiUrl('friends', '/v1/my/friends', useDirectApi)}?limit=100`;\r\n\r\n        console.log(`Fetching friends page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true);\r\n\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch friends: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Friends page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const friends = data.data || [];\r\n        allFriends.push(...friends);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${friends.length} friends, total: ${allFriends.length}`);\r\n\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allFriends.length} total friends`);\r\n    return allFriends;\r\n}\r\n\r\nexport function getAccountAgeInDays(created: string): number {\r\n    const createdDate = new Date(created);\r\n    const now = new Date();\r\n    const diffTime = Math.abs(now.getTime() - createdDate.getTime());\r\n    return Math.floor(diffTime / (1000 * 60 * 60 * 24));\r\n}\r\n\r\nexport async function getAuthenticatedUser(cookie: string, httpProxy?: string): Promise<{ id: number; name: string } | null> {\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        const response = await fetch(getApiUrl('users', '/v1/users/authenticated', useDirectApi), options);\r\n\r\n        if (!response.ok) {\r\n            return null;\r\n        }\r\n\r\n        const data = await response.json();\r\n        return { id: data.id, name: data.name };\r\n    } catch (error) {\r\n        console.error('Error getting authenticated user:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Helper to get avatar thumbnail URL\r\nexport function getAvatarUrl(userId: number): string {\r\n    return `https://thumbnails.roproxy.com/v1/users/avatar-headshot?userIds=${userId}&size=48x48&format=Png&isCircular=false`;\r\n}\r\n\r\ninterface Follower {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n}\r\n\r\n/**\r\n * Get all followers of a user\r\n */\r\nexport async function getFollowers(userId: number, cookie: string, httpProxy?: string): Promise<Follower[]> {\r\n    const allFollowers: Follower[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 50; // Safety limit: 50 pages * 100 = 5000 max followers\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', `/v1/users/${userId}/followers`, useDirectApi)}?limit=100&cursor=${cursor}`\r\n            : `${getApiUrl('friends', `/v1/users/${userId}/followers`, useDirectApi)}?limit=100`;\r\n\r\n        console.log(`Fetching followers page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true);\r\n\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch followers: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Followers page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const followers = data.data || [];\r\n        allFollowers.push(...followers);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${followers.length} followers, total: ${allFollowers.length}`);\r\n\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allFollowers.length} total followers`);\r\n    return allFollowers;\r\n}\r\n\r\n/**\r\n * Send a friend request to a user\r\n */\r\nexport async function sendFriendRequest(targetUserId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${targetUserId}/request-friendship`, useDirectApi);\r\n    console.log(`Sending friend request to user ${targetUserId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                // Check for \"already friends\" or \"pending\" errors\r\n                if (errorText.includes('AlreadyFriends') || errorText.includes('PendingFriendRequest')) {\r\n                    console.log(`Already friends or pending with ${targetUserId}`);\r\n                    return { success: true, skipped: true };\r\n                }\r\n                console.error(`Friend request failed for ${targetUserId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully sent friend request to ${targetUserId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`FriendRequest(${targetUserId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error sending friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kDAAkD;AAClD,6EAA6E;AAC7E;AACA;AAAA;AACA;AACA;;;;;AAiBA,mFAAmF;AACnF,SAAS,gBAAgB,aAAqC,EAAE,SAAkB,EAAE,QAAiB,KAAK;IACtG,+DAA+D;IAC/D,MAAM,UAAkC,QAAQ;QAAE,GAAG,IAAA,oJAAqB,GAAE;IAAC,IAAI,CAAC;IAElF,oEAAoE;IACpE,OAAO,MAAM,CAAC,SAAS;IAEvB,MAAM,UAAuB;QAAE;IAAQ;IAEvC,IAAI,WAAW;QACX,6CAA6C;QAC7C,QAAQ,KAAK,GAAG,IAAI,6KAAe,CAAC;IACxC;IAEA,OAAO;AACX;AAEA,iEAAiE;AACjE,oEAAoE;AACpE,SAAS,UAAU,OAAe,EAAE,IAAY,EAAE,eAAwB,KAAK;IAC3E,IAAI,cAAc;QACd,oBAAoB;QACpB,OAAO,CAAC,QAAQ,EAAE,QAAQ,WAAW,EAAE,MAAM;IACjD;IACA,wDAAwD;IACxD,OAAO,CAAC,QAAQ,EAAE,QAAQ,YAAY,EAAE,MAAM;AAClD;AAEA,mCAAmC;AACnC,MAAM,gBAAgB;AAEf,eAAe,kBAAkB,MAAc,EAAE,SAAkB;IACtE,MAAM,cAA+B,EAAE;IACvC,IAAI,SAAwB;IAC5B,IAAI,YAAY;IAChB,MAAM,WAAW,IAAI,mDAAmD;IACxE,MAAM,eAAe,CAAC,CAAC,WAAW,uCAAuC;IAEzE,GAAG;QACC,MAAM,MAAc,SACd,GAAG,UAAU,WAAW,2BAA2B,cAAc,iCAAiC,EAAE,QAAQ,GAC5G,GAAG,UAAU,WAAW,2BAA2B,cAAc,yBAAyB,CAAC;QAEjG,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,YAAY,EAAE,KAAK,EAAE,eAAe,eAAe,UAAU,CAAC,CAAC;QAE5G,MAAM,UAAU,gBAAgB;YAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACxC,GAAG,WAAW,OAAO,kBAAkB;QAEvC,gCAAgC;QAChC,MAAM,OAAO,MAAM,IAAA,4IAAS,EAAC;YACzB,MAAM,WAAW,MAAM,MAAM,KAAK;YAElC,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,SAAS,MAAM,EAAE;YACzE;YAEA,OAAO,SAAS,IAAI;QACxB,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YAC9F;QACJ;QAEA,MAAM,WAAW,KAAK,IAAI,IAAI,EAAE;QAChC,YAAY,IAAI,IAAI;QAEpB,SAAS,KAAK,cAAc,IAAI;QAChC;QAEA,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,UAAU,MAAM,EAAE,SAAS,MAAM,CAAC,kBAAkB,EAAE,YAAY,MAAM,EAAE;QAE9F,qCAAqC;QACrC,IAAI,QAAQ;YACR,MAAM,IAAA,wIAAK,EAAC,IAAA,gJAAiB,EAAC;QAClC;IAEJ,QAAS,UAAU,YAAY,SAAU;IAEzC,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,YAAY,MAAM,CAAC,sBAAsB,CAAC;IACjE,OAAO;AACX;AAEA,sEAAsE;AACtE,MAAM,qBAAqB;AAC3B,IAAI,mBAAmB;AAEhB,eAAe,YAAY,MAAc,EAAE,SAAkB;IAChE,oDAAoD;IACpD,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,oBAAoB,MAAM;IAChC,MAAM,gBAAgB,IAAA,gJAAiB,EAAC;IAExC,IAAI,oBAAoB,eAAe;QACnC,MAAM,IAAA,wIAAK,EAAC,gBAAgB;IAChC;IACA,mBAAmB,KAAK,GAAG;IAE3B,MAAM,eAAe,CAAC,CAAC;IAEvB,IAAI;QACA,MAAM,UAAU,gBAAgB,CAAC,GAAG,WAAW,OAAO,kBAAkB;QAExE,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MACnB,UAAU,SAAS,CAAC,UAAU,EAAE,QAAQ,EAAE,eAC1C;YAGJ,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,QAAQ,GAAG,CAAC,kCAAkC,QAAQ,WAAW,SAAS,MAAM;gBAChF,OAAO;YACX;YAEA,OAAO,SAAS,IAAI;QACxB,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,YAAY,EAAE,OAAO,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YAC/F;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACX;AACJ;AAEO,eAAe,aAAa,MAAc,EAAE,SAAkB;IACjE,MAAM,eAAe,CAAC,CAAC;IAEvB,IAAI;QACA,MAAM,UAAU,gBAAgB;YAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACxC,GAAG,WAAW,OAAO,kBAAkB;QAEvC,MAAM,WAAW,MAAM,MAAM,UAAU,QAAQ,cAAc,eAAe;YACxE,GAAG,OAAO;YACV,QAAQ;QACZ;QAEA,OAAO,SAAS,OAAO,CAAC,GAAG,CAAC;IAChC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;IACX;AACJ;AAEO,eAAe,oBAAoB,MAAc,EAAE,MAAc,EAAE,SAAiB,EAAE,SAAkB;IAC3G,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,MAAM,UAAU,WAAW,CAAC,UAAU,EAAE,OAAO,sBAAsB,CAAC,EAAE;IAC9E,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,OAAO,KAAK,EAAE,eAAe,WAAW,UAAU,CAAC,CAAC;IAErG,MAAM,UAAU,gBAAgB;QAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACpC,gBAAgB;QAChB,gBAAgB;IACpB,GAAG,WAAW,OAAO,kBAAkB;IAEvC,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,OAAO;gBACV,QAAQ;YACZ;YAEA,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,OAAO,EAAE,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,WAAW;gBAC9E,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;gBAAC;YAC5E;YAEA,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,QAAQ;YACjE,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,OAAO,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YAC1F;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;AAEO,eAAe,qBAAqB,MAAc,EAAE,MAAc,EAAE,SAAiB,EAAE,SAAkB;IAC5G,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,MAAM,UAAU,WAAW,CAAC,UAAU,EAAE,OAAO,uBAAuB,CAAC,EAAE;IAC/E,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,OAAO,KAAK,EAAE,eAAe,WAAW,UAAU,CAAC,CAAC;IAErG,MAAM,UAAU,gBAAgB;QAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACpC,gBAAgB;QAChB,gBAAgB;IACpB,GAAG,WAAW,OAAO,kBAAkB;IAEvC,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,OAAO;gBACV,QAAQ;YACZ;YAEA,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,CAAC,mBAAmB,EAAE,OAAO,EAAE,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,WAAW;gBAC/E,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;gBAAC;YAC5E;YAEA,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,QAAQ;YACjE,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,OAAO,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YAC3F;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mCAAmC;QACjD,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;AAMO,eAAe,yBAAyB,MAAc,EAAE,SAAiB,EAAE,SAAkB;IAChG,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,MAAM,UAAU,WAAW,wCAAwC;IACzE,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,eAAe,WAAW,UAAU,CAAC,CAAC;IAEvF,MAAM,UAAU,gBAAgB;QAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACpC,gBAAgB;QAChB,gBAAgB;IACpB,GAAG,WAAW;IAEd,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,OAAO;gBACV,QAAQ;YACZ;YAEA,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,CAAC,oBAAoB,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,WAAW;gBACrE,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;gBAAC;YAC5E;YAEA,QAAQ,GAAG,CAAC;YACZ,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YACpF;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wCAAwC;QACtD,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;AAEO,eAAe,UAAU,MAAc,EAAE,MAAc,EAAE,SAAiB,EAAE,SAAkB;IACjG,gFAAgF;IAChF,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,WAAW,eAAe,oBAAoB;IACpD,MAAM,MAAM,CAAC,QAAQ,EAAE,SAAS,4BAA4B,EAAE,OAAO,WAAW,CAAC;IAEjF,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,OAAO,KAAK,EAAE,eAAe,yBAAyB,UAAU,CAAC,CAAC;IAE/F,mCAAmC;IACnC,MAAM,gBAAgB,IAAA,oJAAqB;IAC3C,MAAM,iBAAiB,aAAa,CAAC,kBAAkB;IACvD,MAAM,YAAY,aAAa,CAAC,aAAa;IAE7C,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,sDAAsD;YACtD,gDAAgD;YAChD,IAAI,aAAqC,CAAC;YAE1C,IAAI;gBACA,6CAA6C;gBAC7C,MAAM,OAAO,MAAM,OAAO,MAAM,CAAC,WAAW,CACxC;oBAAE,MAAM;oBAAS,YAAY;gBAAQ,GACrC,OACA;oBAAC;iBAAO;gBAGZ,MAAM,YAAY,IAAI,uKAAS,CAAC;oBAC5B;oBACA,QAAQ,CAAC,eAAe,EAAE,QAAQ;gBACtC;gBAEA,mDAAmD;gBACnD,6CAA6C;gBAC7C,aAAa,MAAM,UAAU,mBAAmB,CAC5C,CAAC,mDAAmD,EAAE,OAAO,WAAW,CAAC,EACzE,QACA,MACA,GAAM,aAAa;;gBAGvB,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,QAAQ;YACxD,EAAE,OAAO,UAAU;gBACf,QAAQ,IAAI,CAAC,CAAC,6BAA6B,EAAE,SAAS,uBAAuB,CAAC;YAClF;YAEA,6CAA6C;YAC7C,gDAAgD;YAChD,MAAM,mBAAmB,IAAA,uJAAwB;YAEjD,iDAAiD;YACjD,qEAAqE;YACrE,MAAM,MAAM,IAAI;YAChB,MAAM,aAAa,GAAG,CAAC,IAAI,QAAQ,KAAK,CAAC,EAAE,QAAQ,GAAG,QAAQ,CAAC,GAAG,KAAK,CAAC,EAAE,IAAI,OAAO,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,KAAK,CAAC,EAAE,IAAI,WAAW,GAAG,CAAC,EAAE,IAAI,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,KAAK,CAAC,EAAE,IAAI,UAAU,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,KAAK,CAAC,EAAE,IAAI,UAAU,GAAG,QAAQ,GAAG,QAAQ,CAAC,GAAG,MAAM;YACxR,MAAM,YAAY,OAAO,UAAU;YACnC,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,cAAc,YAAY,yBAAyB;YAE5F,MAAM,aAAa;gBACf,CAAC,4BAA4B,EAAE,WAAW;gBAC1C,CAAC,6BAA6B,EAAE,mBAAmB,YAAY,OAAO,EAAE,MAAM,WAAW,EAAE,kBAAkB;gBAC7G,CAAC,eAAe,EAAE,QAAQ;aAC7B,CAAC,IAAI,CAAC;YAEP,MAAM,cAAc,gBAAgB;gBAChC,kBAAkB;gBAClB,sBAAsB;gBACtB,gBAAgB;gBAChB,mBAAmB;gBACnB,aAAa;gBACb,oBAAoB;gBACpB,wBAAwB;gBACxB,GAAG,UAAU;gBACb,UAAU;gBACV,cAAc;gBACd,UAAU;gBACV,kBAAkB;gBAClB,kBAAkB;gBAClB,kBAAkB;gBAClB,WAAW;gBACX,mBAAmB;gBACnB,YAAY;gBACZ,UAAU;YACd,GAAG,WAAW;YAEd,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,WAAW;gBACd,QAAQ;gBACR,MAAM;YACV;YAEA,QAAQ,GAAG,CAAC,CAAC,mBAAmB,EAAE,OAAO,SAAS,EAAE,SAAS,MAAM,CAAC,SAAS,EAAE,YAAY,QAAQ,KAAK,CAAC,CAAC;YAE1G,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,eAA8B;YAClC,IAAI;gBACA,eAAe,MAAM,SAAS,IAAI;YACtC,EAAE,OAAM;gBACJ,eAAe;YACnB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,QAAQ,KAAK,CAAC,CAAC,iBAAiB,EAAE,OAAO,OAAO,EAAE,SAAS,MAAM,EAAE;gBACnE,QAAQ,KAAK,CAAC,CAAC,eAAe,EAAE,gBAAgB,WAAW;gBAE3D,IAAI,cAAc;oBACd,IAAI;wBACA,MAAM,YAAY,KAAK,KAAK,CAAC;wBAC7B,IAAI,UAAU,MAAM,EAAE,CAAC,EAAE,EAAE,SAAS;4BAChC,OAAO;gCAAE,SAAS;gCAAO,OAAO,UAAU,MAAM,CAAC,EAAE,CAAC,OAAO;4BAAC;wBAChE;oBACJ,EAAE,OAAM;oBACJ,WAAW;oBACf;gBACJ;gBAEA,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,gBAAgB,iBAAiB;gBAAC;YAClG;YAEA,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,QAAQ;YACjD,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,OAAO,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YACzF;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;AAEO,eAAe,aAAa,MAAc,EAAE,MAAc,EAAE,SAAiB,EAAE,SAAkB;IACpG,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,MAAM,UAAU,WAAW,CAAC,UAAU,EAAE,OAAO,SAAS,CAAC,EAAE;IACjE,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,OAAO,KAAK,EAAE,eAAe,WAAW,UAAU,CAAC,CAAC;IAEpF,MAAM,UAAU,gBAAgB;QAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACpC,gBAAgB;QAChB,gBAAgB;IACpB,GAAG,WAAW;IAEd,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,OAAO;gBACV,QAAQ;YACZ;YAEA,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,QAAQ,KAAK,CAAC,CAAC,oBAAoB,EAAE,OAAO,EAAE,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,WAAW;gBAChF,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;gBAAC;YAC5E;YAEA,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,QAAQ;YACpD,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,OAAO,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YAC5F;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ;AAQO,eAAe,WAAW,MAAc,EAAE,SAAkB;IAC/D,MAAM,aAAuB,EAAE;IAC/B,IAAI,SAAwB;IAC5B,IAAI,YAAY;IAChB,MAAM,WAAW,IAAI,kDAAkD;IACvE,MAAM,eAAe,CAAC,CAAC;IAEvB,GAAG;QACC,MAAM,MAAc,SACd,GAAG,UAAU,WAAW,kBAAkB,cAAc,kBAAkB,EAAE,QAAQ,GACpF,GAAG,UAAU,WAAW,kBAAkB,cAAc,UAAU,CAAC;QAEzE,QAAQ,GAAG,CAAC,CAAC,sBAAsB,EAAE,YAAY,EAAE,KAAK,EAAE,eAAe,eAAe,UAAU,CAAC,CAAC;QAEpG,MAAM,UAAU,gBAAgB;YAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACxC,GAAG,WAAW;QAEd,MAAM,OAAO,MAAM,IAAA,4IAAS,EAAC;YACzB,MAAM,WAAW,MAAM,MAAM,KAAK;YAElC,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,SAAS,MAAM,EAAE;YACjE;YAEA,OAAO,SAAS,IAAI;QACxB,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,aAAa,EAAE,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YACtG;QACJ;QAEA,MAAM,UAAU,KAAK,IAAI,IAAI,EAAE;QAC/B,WAAW,IAAI,IAAI;QAEnB,SAAS,KAAK,cAAc,IAAI;QAChC;QAEA,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,UAAU,MAAM,EAAE,QAAQ,MAAM,CAAC,iBAAiB,EAAE,WAAW,MAAM,EAAE;QAE3F,IAAI,QAAQ;YACR,MAAM,IAAA,wIAAK,EAAC,IAAA,gJAAiB,EAAC;QAClC;IAEJ,QAAS,UAAU,YAAY,SAAU;IAEzC,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,WAAW,MAAM,CAAC,cAAc,CAAC;IACxD,OAAO;AACX;AAEO,SAAS,oBAAoB,OAAe;IAC/C,MAAM,cAAc,IAAI,KAAK;IAC7B,MAAM,MAAM,IAAI;IAChB,MAAM,WAAW,KAAK,GAAG,CAAC,IAAI,OAAO,KAAK,YAAY,OAAO;IAC7D,OAAO,KAAK,KAAK,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;AACrD;AAEO,eAAe,qBAAqB,MAAc,EAAE,SAAkB;IACzE,MAAM,eAAe,CAAC,CAAC;IAEvB,IAAI;QACA,MAAM,UAAU,gBAAgB;YAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACxC,GAAG,WAAW,OAAO,kBAAkB;QAEvC,MAAM,WAAW,MAAM,MAAM,UAAU,SAAS,2BAA2B,eAAe;QAE1F,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,OAAO;QACX;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,OAAO;YAAE,IAAI,KAAK,EAAE;YAAE,MAAM,KAAK,IAAI;QAAC;IAC1C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO;IACX;AACJ;AAGO,SAAS,aAAa,MAAc;IACvC,OAAO,CAAC,gEAAgE,EAAE,OAAO,uCAAuC,CAAC;AAC7H;AAWO,eAAe,aAAa,MAAc,EAAE,MAAc,EAAE,SAAkB;IACjF,MAAM,eAA2B,EAAE;IACnC,IAAI,SAAwB;IAC5B,IAAI,YAAY;IAChB,MAAM,WAAW,IAAI,oDAAoD;IACzE,MAAM,eAAe,CAAC,CAAC;IAEvB,GAAG;QACC,MAAM,MAAc,SACd,GAAG,UAAU,WAAW,CAAC,UAAU,EAAE,OAAO,UAAU,CAAC,EAAE,cAAc,kBAAkB,EAAE,QAAQ,GACnG,GAAG,UAAU,WAAW,CAAC,UAAU,EAAE,OAAO,UAAU,CAAC,EAAE,cAAc,UAAU,CAAC;QAExF,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,YAAY,EAAE,KAAK,EAAE,eAAe,eAAe,UAAU,CAAC,CAAC;QAEtG,MAAM,UAAU,gBAAgB;YAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACxC,GAAG,WAAW;QAEd,MAAM,OAAO,MAAM,IAAA,4IAAS,EAAC;YACzB,MAAM,WAAW,MAAM,MAAM,KAAK;YAElC,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,SAAS,MAAM,EAAE;YACnE;YAEA,OAAO,SAAS,IAAI;QACxB,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,eAAe,EAAE,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YACxG;QACJ;QAEA,MAAM,YAAY,KAAK,IAAI,IAAI,EAAE;QACjC,aAAa,IAAI,IAAI;QAErB,SAAS,KAAK,cAAc,IAAI;QAChC;QAEA,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,UAAU,MAAM,EAAE,UAAU,MAAM,CAAC,mBAAmB,EAAE,aAAa,MAAM,EAAE;QAEjG,IAAI,QAAQ;YACR,MAAM,IAAA,wIAAK,EAAC,IAAA,gJAAiB,EAAC;QAClC;IAEJ,QAAS,UAAU,YAAY,SAAU;IAEzC,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,aAAa,MAAM,CAAC,gBAAgB,CAAC;IAC5D,OAAO;AACX;AAKO,eAAe,kBAAkB,YAAoB,EAAE,MAAc,EAAE,SAAiB,EAAE,SAAkB;IAC/G,MAAM,eAAe,CAAC,CAAC;IACvB,MAAM,MAAM,UAAU,WAAW,CAAC,UAAU,EAAE,aAAa,mBAAmB,CAAC,EAAE;IACjF,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,aAAa,KAAK,EAAE,eAAe,WAAW,UAAU,CAAC,CAAC;IAExG,MAAM,UAAU,gBAAgB;QAC5B,UAAU,CAAC,eAAe,EAAE,QAAQ;QACpC,gBAAgB;QAChB,gBAAgB;IACpB,GAAG,WAAW;IAEd,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,4IAAS,EAAC;YAC3B,MAAM,WAAW,MAAM,MAAM,KAAK;gBAC9B,GAAG,OAAO;gBACV,QAAQ;YACZ;YAEA,IAAI,SAAS,MAAM,KAAK,KAAK;gBACzB,MAAM,IAAI,MAAM;YACpB;YAEA,IAAI,CAAC,SAAS,EAAE,EAAE;gBACd,MAAM,YAAY,MAAM,SAAS,IAAI;gBACrC,kDAAkD;gBAClD,IAAI,UAAU,QAAQ,CAAC,qBAAqB,UAAU,QAAQ,CAAC,yBAAyB;oBACpF,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,cAAc;oBAC7D,OAAO;wBAAE,SAAS;wBAAM,SAAS;oBAAK;gBAC1C;gBACA,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,aAAa,EAAE,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,WAAW;gBAC5F,OAAO;oBAAE,SAAS;oBAAO,OAAO,CAAC,KAAK,EAAE,SAAS,MAAM,CAAC,EAAE,EAAE,WAAW;gBAAC;YAC5E;YAEA,QAAQ,GAAG,CAAC,CAAC,oCAAoC,EAAE,cAAc;YACjE,OAAO;gBAAE,SAAS;YAAK;QAC3B,GAAG;YACC,YAAY;YACZ,WAAW;YACX,SAAS,CAAC,SAAS,OAAO;gBACtB,QAAQ,GAAG,CAAC,CAAC,cAAc,EAAE,aAAa,QAAQ,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC;YACvG;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YAAE,SAAS;YAAO,OAAO,OAAO;QAAO;IAClD;AACJ"}},
    {"offset": {"line": 1236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/proxy-pool.ts"],"sourcesContent":["// Proxy Pool - Manages multiple proxies with rotation\r\n\r\nexport interface ProxyPool {\r\n    getNext(): string | undefined;\r\n    getRandom(): string | undefined;\r\n    getAll(): string[];\r\n    size(): number;\r\n    markFailed(proxy: string): void;\r\n    markSuccess(proxy: string): void;\r\n}\r\n\r\ninterface ProxyStats {\r\n    failures: number;\r\n    successes: number;\r\n    lastUsed: number;\r\n}\r\n\r\n/**\r\n * Parse proxy list from various formats\r\n * Supports: newline-separated, comma-separated, JSON array\r\n */\r\nexport function parseProxyList(input: string | null | undefined): string[] {\r\n    if (!input || typeof input !== 'string') {\r\n        return [];\r\n    }\r\n\r\n    const trimmed = input.trim();\r\n\r\n    // Try JSON array first\r\n    if (trimmed.startsWith('[')) {\r\n        try {\r\n            const parsed = JSON.parse(trimmed);\r\n            if (Array.isArray(parsed)) {\r\n                return parsed.filter(p => typeof p === 'string' && p.trim()).map(p => p.trim());\r\n            }\r\n        } catch {\r\n            // Not valid JSON, continue\r\n        }\r\n    }\r\n\r\n    // Split by newlines or commas\r\n    const proxies = trimmed\r\n        .split(/[\\n,]+/)\r\n        .map(p => p.trim())\r\n        .filter(p => p.length > 0 && (p.startsWith('http://') || p.startsWith('https://') || p.includes('@')));\r\n\r\n    return proxies;\r\n}\r\n\r\n/**\r\n * Create a proxy pool with rotation and failure tracking\r\n */\r\nexport function createProxyPool(proxies: string[]): ProxyPool {\r\n    const stats = new Map<string, ProxyStats>();\r\n    let currentIndex = 0;\r\n\r\n    // Initialize stats for all proxies\r\n    proxies.forEach(proxy => {\r\n        stats.set(proxy, { failures: 0, successes: 0, lastUsed: 0 });\r\n    });\r\n\r\n    // Get active proxies (not too many failures)\r\n    const getActiveProxies = (): string[] => {\r\n        return proxies.filter(p => {\r\n            const s = stats.get(p);\r\n            // Filter out proxies with 5+ consecutive failures\r\n            return !s || s.failures < 5;\r\n        });\r\n    };\r\n\r\n    return {\r\n        /**\r\n         * Get next proxy in rotation (round-robin)\r\n         */\r\n        getNext(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            currentIndex = (currentIndex + 1) % active.length;\r\n            const proxy = active[currentIndex];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get a random proxy (good for avoiding patterns)\r\n         */\r\n        getRandom(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            const proxy = active[Math.floor(Math.random() * active.length)];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get all proxies\r\n         */\r\n        getAll(): string[] {\r\n            return [...proxies];\r\n        },\r\n\r\n        /**\r\n         * Get number of active proxies\r\n         */\r\n        size(): number {\r\n            return getActiveProxies().length;\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as failed\r\n         */\r\n        markFailed(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.failures++;\r\n                s.successes = 0; // Reset success count on failure\r\n                console.log(`Proxy marked failed (${s.failures}x): ${proxy.replace(/:.*@/, ':***@')}`);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as successful\r\n         */\r\n        markSuccess(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.successes++;\r\n                s.failures = 0; // Reset failure count on success\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Get a single proxy or create a pool from the input\r\n * Returns either a single proxy string or a ProxyPool\r\n */\r\nexport function getProxyOrPool(httpProxy: string | null | undefined): string | ProxyPool | undefined {\r\n    if (!httpProxy) return undefined;\r\n\r\n    const proxies = parseProxyList(httpProxy);\r\n\r\n    if (proxies.length === 0) {\r\n        return undefined;\r\n    } else if (proxies.length === 1) {\r\n        return proxies[0];\r\n    } else {\r\n        return createProxyPool(proxies);\r\n    }\r\n}\r\n\r\n/**\r\n * Get the next proxy from either a single proxy or a pool\r\n */\r\nexport function getNextProxy(proxyOrPool: string | ProxyPool | undefined): string | undefined {\r\n    if (!proxyOrPool) return undefined;\r\n\r\n    if (typeof proxyOrPool === 'string') {\r\n        return proxyOrPool;\r\n    }\r\n\r\n    return proxyOrPool.getRandom(); // Use random for better distribution\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/global-proxy.ts"],"sourcesContent":["// Global Proxy Pool - managed via admin panel, stored in database\r\nimport { parseProxyList, createProxyPool, ProxyPool } from './proxy-pool';\r\nimport { supabase } from './supabase';\r\n\r\nlet globalProxyPool: ProxyPool | null = null;\r\nlet proxyList: string[] = [];\r\nlet lastFetch = 0;\r\nconst CACHE_TTL = 60000; // Refresh every 60 seconds\r\n\r\n// Fetch proxies from database\r\nasync function fetchProxiesFromDB(): Promise<string[]> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        if (data?.value) {\r\n            return parseProxyList(data.value);\r\n        }\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error fetching from DB:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Initialize/refresh proxies\r\nasync function initGlobalProxies(force = false) {\r\n    const now = Date.now();\r\n\r\n    // Use cache if not expired\r\n    if (!force && now - lastFetch < CACHE_TTL && proxyList.length > 0) {\r\n        return;\r\n    }\r\n\r\n    proxyList = await fetchProxiesFromDB();\r\n    lastFetch = now;\r\n\r\n    if (proxyList.length > 1) {\r\n        globalProxyPool = createProxyPool(proxyList);\r\n        console.log(`[Global Proxy] Pool initialized with ${proxyList.length} proxies`);\r\n    } else if (proxyList.length === 1) {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] Using single proxy`);\r\n    } else {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] No proxies configured`);\r\n    }\r\n}\r\n\r\n// Get next proxy from global pool\r\nexport async function getGlobalProxy(): Promise<string | undefined> {\r\n    await initGlobalProxies();\r\n\r\n    if (globalProxyPool) {\r\n        return globalProxyPool.getNext();\r\n    }\r\n\r\n    return proxyList[0] || undefined;\r\n}\r\n\r\n// Get proxy count\r\nexport async function getGlobalProxyCount(): Promise<number> {\r\n    await initGlobalProxies();\r\n    return proxyList.length;\r\n}\r\n\r\n// Force refresh proxies (call after admin updates)\r\nexport async function refreshGlobalProxies(): Promise<void> {\r\n    await initGlobalProxies(true);\r\n}\r\n\r\n// Save proxies to database (admin only)\r\nexport async function saveGlobalProxies(proxies: string): Promise<boolean> {\r\n    try {\r\n        const { error } = await supabase\r\n            .from('app_settings')\r\n            .upsert({\r\n                key: 'proxy_list',\r\n                value: proxies,\r\n                updated_at: new Date().toISOString()\r\n            }, { onConflict: 'key' });\r\n\r\n        if (error) {\r\n            console.error('[Global Proxy] Error saving:', error);\r\n            return false;\r\n        }\r\n\r\n        // Refresh cache\r\n        await refreshGlobalProxies();\r\n        return true;\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error saving:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n// Get raw proxy list (for admin display)\r\nexport async function getGlobalProxyList(): Promise<string> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        return data?.value || '';\r\n    } catch {\r\n        return '';\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA,kEAAkE;AAClE;AACA;;;AAEA,IAAI,kBAAoC;AACxC,IAAI,YAAsB,EAAE;AAC5B,IAAI,YAAY;AAChB,MAAM,YAAY,OAAO,2BAA2B;AAEpD,8BAA8B;AAC9B,eAAe;IACX,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,IAAI,MAAM,OAAO;YACb,OAAO,IAAA,+IAAc,EAAC,KAAK,KAAK;QACpC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,0CAA0C;IAC5D;IACA,OAAO,EAAE;AACb;AAEA,6BAA6B;AAC7B,eAAe,kBAAkB,QAAQ,KAAK;IAC1C,MAAM,MAAM,KAAK,GAAG;IAEpB,2BAA2B;IAC3B,IAAI,CAAC,SAAS,MAAM,YAAY,aAAa,UAAU,MAAM,GAAG,GAAG;QAC/D;IACJ;IAEA,YAAY,MAAM;IAClB,YAAY;IAEZ,IAAI,UAAU,MAAM,GAAG,GAAG;QACtB,kBAAkB,IAAA,gJAAe,EAAC;QAClC,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,UAAU,MAAM,CAAC,QAAQ,CAAC;IAClF,OAAO,IAAI,UAAU,MAAM,KAAK,GAAG;QAC/B,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,iCAAiC,CAAC;IACnD,OAAO;QACH,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,oCAAoC,CAAC;IACtD;AACJ;AAGO,eAAe;IAClB,MAAM;IAEN,IAAI,iBAAiB;QACjB,OAAO,gBAAgB,OAAO;IAClC;IAEA,OAAO,SAAS,CAAC,EAAE,IAAI;AAC3B;AAGO,eAAe;IAClB,MAAM;IACN,OAAO,UAAU,MAAM;AAC3B;AAGO,eAAe;IAClB,MAAM,kBAAkB;AAC5B;AAGO,eAAe,kBAAkB,OAAe;IACnD,IAAI;QACA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CAC3B,IAAI,CAAC,gBACL,MAAM,CAAC;YACJ,KAAK;YACL,OAAO;YACP,YAAY,IAAI,OAAO,WAAW;QACtC,GAAG;YAAE,YAAY;QAAM;QAE3B,IAAI,OAAO;YACP,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,OAAO;QACX;QAEA,gBAAgB;QAChB,MAAM;QACN,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;IACX;AACJ;AAGO,eAAe;IAClB,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,OAAO,MAAM,SAAS;IAC1B,EAAE,OAAM;QACJ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 1463, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/app/api/filter/remove-all-friends/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { getCurrentUser } from '@/lib/auth';\r\nimport { getFriends, unfriendUser, getCSRFToken, getAuthenticatedUser } from '@/lib/roblox';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { getGlobalProxy, getGlobalProxyCount } from '@/lib/global-proxy';\r\n\r\nexport async function POST(request: NextRequest) {\r\n    const encoder = new TextEncoder();\r\n\r\n    const stream = new ReadableStream({\r\n        async start(controller) {\r\n            const sendEvent = (data: object) => {\r\n                controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\\n\\n`));\r\n            };\r\n\r\n            try {\r\n                const user = await getCurrentUser();\r\n\r\n                if (!user) {\r\n                    sendEvent({ type: 'error', message: 'Not authenticated' });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                const body = await request.json().catch(() => ({}));\r\n                const accountId = body.accountId;\r\n\r\n                let cookie: string | null = null;\r\n\r\n                if (accountId) {\r\n                    const { data: account } = await supabase\r\n                        .from('roblox_accounts')\r\n                        .select('cookie')\r\n                        .eq('id', accountId)\r\n                        .eq('user_id', user.id)\r\n                        .single();\r\n\r\n                    if (!account) {\r\n                        sendEvent({ type: 'error', message: 'Account not found' });\r\n                        controller.close();\r\n                        return;\r\n                    }\r\n                    cookie = account.cookie;\r\n                } else {\r\n                    cookie = user.roblox_cookie;\r\n                }\r\n\r\n                if (!cookie) {\r\n                    sendEvent({ type: 'error', message: 'No Roblox account configured' });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                sendEvent({ type: 'progress', phase: 'Initializing...', percent: 0, removed: 0, total: 0 });\r\n\r\n                const proxyCount = await getGlobalProxyCount();\r\n                const authUser = await getAuthenticatedUser(cookie, await getGlobalProxy());\r\n                const csrfToken = await getCSRFToken(cookie, await getGlobalProxy());\r\n\r\n                if (!csrfToken) {\r\n                    sendEvent({ type: 'error', message: 'Failed to get CSRF token' });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                sendEvent({ type: 'progress', phase: 'Fetching friends list...', percent: 5, removed: 0, total: 0 });\r\n\r\n                // Fetch all friends\r\n                const friends = await getFriends(cookie, await getGlobalProxy());\r\n\r\n                if (friends.length === 0) {\r\n                    sendEvent({ type: 'complete', removed: 0, total: 0 });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                const total = friends.length;\r\n                let removed = 0;\r\n                const logs: { action: string; username: string; userId: string }[] = [];\r\n\r\n                const delayBetweenUsers = proxyCount > 10 ? 100 : proxyCount > 1 ? 200 : 400;\r\n\r\n                sendEvent({ type: 'progress', phase: `Removing ${total} friends...`, percent: 10, removed: 0, total });\r\n\r\n                for (let i = 0; i < friends.length; i++) {\r\n                    const friend = friends[i];\r\n                    const proxy = await getGlobalProxy();\r\n\r\n                    try {\r\n                        const result = await unfriendUser(friend.id, cookie!, csrfToken, proxy);\r\n\r\n                        if (result.success) {\r\n                            removed++;\r\n                            logs.push({\r\n                                action: 'unfriended',\r\n                                username: friend.name,\r\n                                userId: String(friend.id),\r\n                            });\r\n                        }\r\n                    } catch (error) {\r\n                        console.error(`Failed to unfriend ${friend.name}:`, error);\r\n                    }\r\n\r\n                    // Send progress update\r\n                    const percent = 10 + Math.round(((i + 1) / total) * 88);\r\n                    sendEvent({\r\n                        type: 'progress',\r\n                        phase: `Removing ${friend.name}...`,\r\n                        percent,\r\n                        removed,\r\n                        total\r\n                    });\r\n\r\n                    // Add delay between users\r\n                    if (i < friends.length - 1) {\r\n                        await new Promise(resolve => setTimeout(resolve, delayBetweenUsers));\r\n                    }\r\n                }\r\n\r\n                // Save logs to database\r\n                if (logs.length > 0) {\r\n                    await supabase.from('filter_logs').insert(\r\n                        logs.map(log => ({\r\n                            user_id: user.id,\r\n                            action: log.action,\r\n                            roblox_username: log.username,\r\n                            roblox_user_id: log.userId,\r\n                            roblox_account_name: authUser?.name || null,\r\n                            reason: 'Remove all friends',\r\n                        }))\r\n                    );\r\n                }\r\n\r\n                sendEvent({ type: 'complete', removed, total });\r\n                controller.close();\r\n\r\n            } catch (error) {\r\n                console.error('Error in remove all friends:', error);\r\n                sendEvent({ type: 'error', message: 'Remove all friends failed' });\r\n                controller.close();\r\n            }\r\n        }\r\n    });\r\n\r\n    return new Response(stream, {\r\n        headers: {\r\n            'Content-Type': 'text/event-stream',\r\n            'Cache-Control': 'no-cache',\r\n            'Connection': 'keep-alive',\r\n        },\r\n    });\r\n}\r\n"],"names":[],"mappings":"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"}}]
}