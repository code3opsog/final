{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { supabase } from './supabase';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'fallback-secret');\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    discordId: string;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport async function createSession(userId: string, discordId: string, isAdmin: boolean, ip?: string, userAgent?: string) {\r\n    const token = await new SignJWT({ userId, discordId, isAdmin })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setExpirationTime('7d')\r\n        .sign(JWT_SECRET);\r\n\r\n    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n    await supabase.from('sessions').insert({\r\n        user_id: userId,\r\n        token,\r\n        ip,\r\n        user_agent: userAgent,\r\n        expires_at: expiresAt,\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function verifySession(token: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n\r\n        console.log('verifySession - JWT payload:', payload);\r\n\r\n        // Simple query without join\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('token', token)\r\n            .single();\r\n\r\n        if (sessionError) {\r\n            console.error('verifySession - Session query error:', sessionError);\r\n            return null;\r\n        }\r\n\r\n        if (!session || new Date(session.expires_at) < new Date()) {\r\n            console.log('verifySession - Session expired or not found');\r\n            return null;\r\n        }\r\n\r\n        // Get user separately\r\n        const { data: user, error: userError } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user_id)\r\n            .single();\r\n\r\n        if (userError || !user) {\r\n            console.error('verifySession - User query error:', userError);\r\n            return null;\r\n        }\r\n\r\n        console.log('verifySession - Success, user:', user.username);\r\n\r\n        return {\r\n            userId: session.user_id,\r\n            discordId: user.discord_id,\r\n            isAdmin: user.is_admin,\r\n        };\r\n    } catch (error) {\r\n        console.error('verifySession - JWT or other error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('session')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    const payload = await verifySession(token);\r\n    if (!payload) return null;\r\n\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', payload.userId)\r\n        .single();\r\n\r\n    return user;\r\n}\r\n\r\nexport async function isUserAuthorized(userId: string): Promise<boolean> {\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n    if (!user) return false;\r\n    if (user.is_admin) return true;\r\n    if (!user.is_authorized) return false;\r\n    if (user.auth_expiry && new Date(user.auth_expiry) < new Date()) return false;\r\n\r\n    return true;\r\n}\r\n\r\nexport function getDiscordOAuthUrl() {\r\n    const params = new URLSearchParams({\r\n        client_id: process.env.DISCORD_CLIENT_ID!,\r\n        redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        response_type: 'code',\r\n        scope: 'identify email',\r\n    });\r\n\r\n    return `https://discord.com/api/oauth2/authorize?${params.toString()}`;\r\n}\r\n\r\nexport async function exchangeCodeForToken(code: string) {\r\n    const response = await fetch('https://discord.com/api/oauth2/token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n        body: new URLSearchParams({\r\n            client_id: process.env.DISCORD_CLIENT_ID!,\r\n            client_secret: process.env.DISCORD_CLIENT_SECRET!,\r\n            grant_type: 'authorization_code',\r\n            code,\r\n            redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        }),\r\n    });\r\n\r\n    return response.json();\r\n}\r\n\r\nexport async function getDiscordUser(accessToken: string) {\r\n    const response = await fetch('https://discord.com/api/users/@me', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    });\r\n\r\n    return response.json();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/friend-request-service.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport interface CachedFriendRequest {\r\n    id: number;  // Roblox user ID\r\n    username: string;\r\n    displayName: string;\r\n    avatarUrl: string;\r\n    created: string | null;\r\n    isBanned: boolean;\r\n    isBot: boolean;\r\n    botScore: number;\r\n    botReason: string | null;\r\n    status: 'pending' | 'accepted' | 'declined' | 'blocked';\r\n}\r\n\r\nexport type RequestFilter = 'all' | 'bots' | 'safe';\r\n\r\n/**\r\n * Save friend requests to JSONB column (single row per account)\r\n * Merges new requests with existing cache, preserving processed statuses\r\n * Only adds truly new requests to avoid unnecessary database updates\r\n */\r\nexport async function saveFriendRequests(\r\n    accountId: string,\r\n    requests: Omit<CachedFriendRequest, 'status'>[]\r\n): Promise<boolean> {\r\n    // First, get existing cache to preserve already processed requests\r\n    const { data: existingData } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    const existingRequests = (existingData?.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Create a set of existing request IDs for quick lookup\r\n    const existingIds = new Set(existingRequests.map(r => r.id));\r\n\r\n    // Find truly new requests (not already in cache)\r\n    const newRequests = requests.filter(r => !existingIds.has(r.id));\r\n\r\n    // If no new requests, skip the update entirely\r\n    if (newRequests.length === 0) {\r\n        console.log(`[Friend Request Service] No new requests for account ${accountId}, skipping update`);\r\n        return true;\r\n    }\r\n\r\n    console.log(`[Friend Request Service] Found ${newRequests.length} new requests out of ${requests.length} total`);\r\n\r\n    // Add pending status to new requests only\r\n    const newRequestsWithStatus: CachedFriendRequest[] = newRequests.map(r => ({\r\n        ...r,\r\n        status: 'pending' as const\r\n    }));\r\n\r\n    // Merge: keep existing pending requests + add new ones\r\n    // Remove requests that are no longer in the friend request list (already removed by Roblox)\r\n    const currentIds = new Set(requests.map(r => r.id));\r\n    const stillPendingExisting = existingRequests.filter(r =>\r\n        r.status === 'pending' && currentIds.has(r.id)\r\n    );\r\n\r\n    const mergedRequests = [...stillPendingExisting, ...newRequestsWithStatus];\r\n\r\n    // Compute stats from merged data\r\n    const pendingRequests = mergedRequests.filter(r => r.status === 'pending');\r\n    const botsCount = pendingRequests.filter(r => r.isBot).length;\r\n    const safeCount = pendingRequests.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: mergedRequests,\r\n            cached_at: new Date().toISOString(),\r\n            cached_total: pendingRequests.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    if (error) {\r\n        console.error('Failed to save friend requests:', error);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Get cached friend requests with filter (from JSONB column)\r\n * Also filters out users who have been added to the blacklist since caching\r\n */\r\nexport async function getCachedRequests(\r\n    accountId: string,\r\n    filter: RequestFilter = 'all'\r\n): Promise<{\r\n    requests: CachedFriendRequest[];\r\n    cachedAt: string | null;\r\n    total: number;\r\n    bots: number;\r\n    safe: number;\r\n} | null> {\r\n    // Fetch cached requests and blacklist in parallel\r\n    const [accountResult, blacklistResult] = await Promise.all([\r\n        supabase\r\n            .from('roblox_accounts')\r\n            .select('cached_friend_requests, cached_at, cached_total, cached_bots, cached_safe')\r\n            .eq('id', accountId)\r\n            .single(),\r\n        supabase\r\n            .from('roblox_blacklist')\r\n            .select('username, roblox_user_id')\r\n    ]);\r\n\r\n    if (accountResult.error || !accountResult.data) {\r\n        console.error('Failed to get cached requests:', accountResult.error);\r\n        return null;\r\n    }\r\n\r\n    const data = accountResult.data;\r\n    let requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Create sets for both blacklisted usernames and user IDs for efficient lookup\r\n    const blacklistedUsernames = new Set<string>();\r\n    const blacklistedUserIds = new Set<number>();\r\n\r\n    (blacklistResult.data || []).forEach((b: { username: string; roblox_user_id: string | null }) => {\r\n        blacklistedUsernames.add(b.username.toLowerCase());\r\n        if (b.roblox_user_id) {\r\n            blacklistedUserIds.add(parseInt(b.roblox_user_id, 10));\r\n        }\r\n    });\r\n\r\n    // Helper to check if a user is blacklisted (by username OR user ID)\r\n    const isBlacklisted = (r: CachedFriendRequest) =>\r\n        blacklistedUsernames.has(r.username.toLowerCase()) || blacklistedUserIds.has(r.id);\r\n\r\n    // Filter to only pending requests AND exclude blacklisted users\r\n    requests = requests.filter(r =>\r\n        r.status === 'pending' &&\r\n        !isBlacklisted(r)\r\n    );\r\n\r\n    // Apply additional filter\r\n    if (filter === 'bots') {\r\n        requests = requests.filter(r => r.isBot);\r\n    } else if (filter === 'safe') {\r\n        requests = requests.filter(r => !r.isBot);\r\n    }\r\n\r\n    // Recalculate totals after filtering out blacklisted users\r\n    const allPendingNonBlacklisted = ((data.cached_friend_requests as CachedFriendRequest[]) || [])\r\n        .filter(r => r.status === 'pending' && !isBlacklisted(r));\r\n\r\n    const total = allPendingNonBlacklisted.length;\r\n    const bots = allPendingNonBlacklisted.filter(r => r.isBot).length;\r\n    const safe = allPendingNonBlacklisted.filter(r => !r.isBot).length;\r\n\r\n    return {\r\n        requests,\r\n        cachedAt: data.cached_at as string | null,\r\n        total,\r\n        bots,\r\n        safe\r\n    };\r\n}\r\n\r\n/**\r\n * Get just the stats without loading full data\r\n */\r\nexport async function getRequestStats(accountId: string): Promise<{\r\n    total: number;\r\n    bots: number;\r\n    safe: number;\r\n    cachedAt: string | null;\r\n} | null> {\r\n    const { data, error } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_total, cached_bots, cached_safe, cached_at')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (error || !data) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        total: (data.cached_total as number) || 0,\r\n        bots: (data.cached_bots as number) || 0,\r\n        safe: (data.cached_safe as number) || 0,\r\n        cachedAt: data.cached_at as string | null\r\n    };\r\n}\r\n\r\n/**\r\n * Update a single request's status in JSONB\r\n */\r\nexport async function updateRequestStatus(\r\n    accountId: string,\r\n    robloxUserId: string,\r\n    status: 'accepted' | 'declined' | 'blocked'\r\n): Promise<boolean> {\r\n    // Get current cache\r\n    const { data } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (!data) return false;\r\n\r\n    const requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n\r\n    // Update status and remove from pending\r\n    const updated = requests.filter(r => r.id !== parseInt(robloxUserId));\r\n\r\n    // Recompute counts\r\n    const pending = updated.filter(r => r.status === 'pending');\r\n    const botsCount = pending.filter(r => r.isBot).length;\r\n    const safeCount = pending.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: updated,\r\n            cached_total: pending.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Bulk update status for multiple requests\r\n */\r\nexport async function bulkUpdateStatus(\r\n    accountId: string,\r\n    robloxUserIds: string[],\r\n    status: 'accepted' | 'declined' | 'blocked'\r\n): Promise<boolean> {\r\n    if (robloxUserIds.length === 0) return true;\r\n\r\n    const { data } = await supabase\r\n        .from('roblox_accounts')\r\n        .select('cached_friend_requests')\r\n        .eq('id', accountId)\r\n        .single();\r\n\r\n    if (!data) return false;\r\n\r\n    const requests = (data.cached_friend_requests as CachedFriendRequest[]) || [];\r\n    const idsToRemove = new Set(robloxUserIds.map(id => parseInt(id)));\r\n\r\n    // Remove processed requests\r\n    const updated = requests.filter(r => !idsToRemove.has(r.id));\r\n\r\n    // Recompute counts\r\n    const pending = updated.filter(r => r.status === 'pending');\r\n    const botsCount = pending.filter(r => r.isBot).length;\r\n    const safeCount = pending.filter(r => !r.isBot).length;\r\n\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: updated,\r\n            cached_total: pending.length,\r\n            cached_bots: botsCount,\r\n            cached_safe: safeCount\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Clear all cached requests\r\n */\r\nexport async function clearCache(accountId: string): Promise<boolean> {\r\n    const { error } = await supabase\r\n        .from('roblox_accounts')\r\n        .update({\r\n            cached_friend_requests: [],\r\n            cached_at: null,\r\n            cached_total: 0,\r\n            cached_bots: 0,\r\n            cached_safe: 0\r\n        })\r\n        .eq('id', accountId);\r\n\r\n    return !error;\r\n}\r\n\r\n/**\r\n * Remove a single user from cache\r\n */\r\nexport async function removeFromCache(\r\n    accountId: string,\r\n    robloxUserId: number\r\n): Promise<boolean> {\r\n    return updateRequestStatus(accountId, String(robloxUserId), 'declined');\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/app/api/filter/cached/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getCurrentUser } from '@/lib/auth';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { getCachedRequests, RequestFilter } from '@/lib/friend-request-service';\r\n\r\n/**\r\n * GET /api/filter/cached?accountId=xxx&filter=all|bots|safe\r\n * Returns cached friend requests from database with optional filtering\r\n */\r\nexport async function GET(request: NextRequest) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n\r\n        if (!user) {\r\n            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\r\n        }\r\n\r\n        const { searchParams } = new URL(request.url);\r\n        const accountId = searchParams.get('accountId');\r\n        const filter = (searchParams.get('filter') || 'all') as RequestFilter;\r\n\r\n        if (!accountId) {\r\n            return NextResponse.json({ error: 'Account ID required' }, { status: 400 });\r\n        }\r\n\r\n        // Validate filter param\r\n        if (!['all', 'bots', 'safe'].includes(filter)) {\r\n            return NextResponse.json({ error: 'Invalid filter. Use: all, bots, safe' }, { status: 400 });\r\n        }\r\n\r\n        // Verify account belongs to user\r\n        const { data: account } = await supabase\r\n            .from('roblox_accounts')\r\n            .select('id, account_name, cached_at')\r\n            .eq('id', accountId)\r\n            .eq('user_id', user.id)\r\n            .single();\r\n\r\n        if (!account) {\r\n            return NextResponse.json({ error: 'Account not found' }, { status: 404 });\r\n        }\r\n\r\n        // Get cached requests from friend_requests table with filter\r\n        const cached = await getCachedRequests(accountId, filter);\r\n\r\n        if (!cached) {\r\n            return NextResponse.json({\r\n                requests: [],\r\n                cachedAt: null,\r\n                accountName: account.account_name,\r\n                total: 0,\r\n                bots: 0,\r\n                safe: 0,\r\n                filter\r\n            });\r\n        }\r\n\r\n        return NextResponse.json({\r\n            requests: cached.requests,\r\n            cachedAt: cached.cachedAt,\r\n            accountName: account.account_name,\r\n            total: cached.total,\r\n            bots: cached.bots,\r\n            safe: cached.safe,\r\n            filter,\r\n            filteredCount: cached.requests.length\r\n        });\r\n    } catch (error) {\r\n        console.error('Error getting cached requests:', error);\r\n        return NextResponse.json({ error: 'Failed to get cached requests' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAMO,eAAe,IAAI,OAAoB;IAC1C,IAAI;QACA,MAAM,OAAO,MAAM,IAAA,sIAAc;QAEjC,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,SAAU,aAAa,GAAG,CAAC,aAAa;QAE9C,IAAI,CAAC,WAAW;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,wBAAwB;QACxB,IAAI,CAAC;YAAC;YAAO;YAAQ;SAAO,CAAC,QAAQ,CAAC,SAAS;YAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAuC,GAAG;gBAAE,QAAQ;YAAI;QAC9F;QAEA,iCAAiC;QACjC,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,oIAAQ,CACnC,IAAI,CAAC,mBACL,MAAM,CAAC,+BACP,EAAE,CAAC,MAAM,WACT,EAAE,CAAC,WAAW,KAAK,EAAE,EACrB,MAAM;QAEX,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,6DAA6D;QAC7D,MAAM,SAAS,MAAM,IAAA,iKAAiB,EAAC,WAAW;QAElD,IAAI,CAAC,QAAQ;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACrB,UAAU,EAAE;gBACZ,UAAU;gBACV,aAAa,QAAQ,YAAY;gBACjC,OAAO;gBACP,MAAM;gBACN,MAAM;gBACN;YACJ;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,UAAU,OAAO,QAAQ;YACzB,UAAU,OAAO,QAAQ;YACzB,aAAa,QAAQ,YAAY;YACjC,OAAO,OAAO,KAAK;YACnB,MAAM,OAAO,IAAI;YACjB,MAAM,OAAO,IAAI;YACjB;YACA,eAAe,OAAO,QAAQ,CAAC,MAAM;QACzC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAgC,GAAG;YAAE,QAAQ;QAAI;IACvF;AACJ"}}]
}