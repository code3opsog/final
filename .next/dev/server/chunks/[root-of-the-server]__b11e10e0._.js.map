{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { supabase } from './supabase';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'fallback-secret');\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    discordId: string;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport async function createSession(userId: string, discordId: string, isAdmin: boolean, ip?: string, userAgent?: string) {\r\n    const token = await new SignJWT({ userId, discordId, isAdmin })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setExpirationTime('7d')\r\n        .sign(JWT_SECRET);\r\n\r\n    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n    await supabase.from('sessions').insert({\r\n        user_id: userId,\r\n        token,\r\n        ip,\r\n        user_agent: userAgent,\r\n        expires_at: expiresAt,\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function verifySession(token: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n\r\n        console.log('verifySession - JWT payload:', payload);\r\n\r\n        // Simple query without join\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('token', token)\r\n            .single();\r\n\r\n        if (sessionError) {\r\n            console.error('verifySession - Session query error:', sessionError);\r\n            return null;\r\n        }\r\n\r\n        if (!session || new Date(session.expires_at) < new Date()) {\r\n            console.log('verifySession - Session expired or not found');\r\n            return null;\r\n        }\r\n\r\n        // Get user separately\r\n        const { data: user, error: userError } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user_id)\r\n            .single();\r\n\r\n        if (userError || !user) {\r\n            console.error('verifySession - User query error:', userError);\r\n            return null;\r\n        }\r\n\r\n        console.log('verifySession - Success, user:', user.username);\r\n\r\n        return {\r\n            userId: session.user_id,\r\n            discordId: user.discord_id,\r\n            isAdmin: user.is_admin,\r\n        };\r\n    } catch (error) {\r\n        console.error('verifySession - JWT or other error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('session')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    const payload = await verifySession(token);\r\n    if (!payload) return null;\r\n\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', payload.userId)\r\n        .single();\r\n\r\n    return user;\r\n}\r\n\r\nexport async function isUserAuthorized(userId: string): Promise<boolean> {\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n    if (!user) return false;\r\n    if (user.is_admin) return true;\r\n    if (!user.is_authorized) return false;\r\n    if (user.auth_expiry && new Date(user.auth_expiry) < new Date()) return false;\r\n\r\n    return true;\r\n}\r\n\r\nexport function getDiscordOAuthUrl() {\r\n    const params = new URLSearchParams({\r\n        client_id: process.env.DISCORD_CLIENT_ID!,\r\n        redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        response_type: 'code',\r\n        scope: 'identify email',\r\n    });\r\n\r\n    return `https://discord.com/api/oauth2/authorize?${params.toString()}`;\r\n}\r\n\r\nexport async function exchangeCodeForToken(code: string) {\r\n    const response = await fetch('https://discord.com/api/oauth2/token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n        body: new URLSearchParams({\r\n            client_id: process.env.DISCORD_CLIENT_ID!,\r\n            client_secret: process.env.DISCORD_CLIENT_SECRET!,\r\n            grant_type: 'authorization_code',\r\n            code,\r\n            redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        }),\r\n    });\r\n\r\n    return response.json();\r\n}\r\n\r\nexport async function getDiscordUser(accessToken: string) {\r\n    const response = await fetch('https://discord.com/api/users/@me', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    });\r\n\r\n    return response.json();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 240, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/rate-limiter.ts"],"sourcesContent":["// Advanced Rate Limiter Utility\r\n// Implements: Throttling, Exponential Backoff, Jitter, Batch Processing\r\n\r\n/**\r\n * Sleep for a given number of milliseconds\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/**\r\n * Add random jitter to a delay to avoid detection patterns\r\n * @param baseDelay - Base delay in ms\r\n * @param jitterPercent - Jitter percentage (0-1), default 0.3 (30%)\r\n */\r\nexport function addJitter(baseDelay: number, jitterPercent: number = 0.3): number {\r\n    const jitter = baseDelay * jitterPercent * (Math.random() * 2 - 1);\r\n    return Math.max(0, baseDelay + jitter);\r\n}\r\n\r\n/**\r\n * Calculate exponential backoff delay\r\n * @param attempt - Current attempt number (0-indexed)\r\n * @param baseDelay - Base delay in ms, default 1000\r\n * @param maxDelay - Maximum delay in ms, default 30000\r\n */\r\nexport function exponentialBackoff(attempt: number, baseDelay: number = 1000, maxDelay: number = 30000): number {\r\n    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\r\n    return addJitter(delay);\r\n}\r\n\r\ninterface RetryOptions {\r\n    maxRetries?: number;\r\n    baseDelay?: number;\r\n    maxDelay?: number;\r\n    onRetry?: (attempt: number, error: Error, delay: number) => void;\r\n}\r\n\r\n/**\r\n * Execute a function with retry and exponential backoff\r\n */\r\nexport async function withRetry<T>(\r\n    fn: () => Promise<T>,\r\n    options: RetryOptions = {}\r\n): Promise<T> {\r\n    const {\r\n        maxRetries = 3,\r\n        baseDelay = 1000,\r\n        maxDelay = 30000,\r\n        onRetry\r\n    } = options;\r\n\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n        try {\r\n            return await fn();\r\n        } catch (error) {\r\n            lastError = error as Error;\r\n\r\n            // Check if it's a rate limit error (429)\r\n            const isRateLimit = error instanceof Error &&\r\n                (error.message.includes('429') || error.message.includes('rate limit'));\r\n\r\n            if (attempt < maxRetries) {\r\n                const delay = isRateLimit\r\n                    ? exponentialBackoff(attempt, baseDelay * 2, maxDelay) // Longer delay for rate limits\r\n                    : exponentialBackoff(attempt, baseDelay, maxDelay);\r\n\r\n                if (onRetry) {\r\n                    onRetry(attempt + 1, lastError, delay);\r\n                }\r\n\r\n                console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms...`);\r\n                await sleep(delay);\r\n            }\r\n        }\r\n    }\r\n\r\n    throw lastError;\r\n}\r\n\r\ninterface ThrottleOptions {\r\n    minDelay?: number;      // Minimum delay between requests (ms)\r\n    maxDelay?: number;      // Maximum delay for backoff (ms)\r\n    requestsPerSecond?: number;  // Target requests per second\r\n}\r\n\r\n/**\r\n * Creates a throttled request queue that respects rate limits\r\n */\r\nexport function createThrottledQueue(options: ThrottleOptions = {}) {\r\n    const {\r\n        minDelay = 100,\r\n        maxDelay = 5000,\r\n        requestsPerSecond = 5\r\n    } = options;\r\n\r\n    const delayPerRequest = 1000 / requestsPerSecond;\r\n    let lastRequestTime = 0;\r\n    let consecutiveErrors = 0;\r\n    let currentDelay = Math.max(minDelay, delayPerRequest);\r\n\r\n    return {\r\n        /**\r\n         * Execute a request with throttling\r\n         */\r\n        async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n            // Calculate time since last request\r\n            const now = Date.now();\r\n            const timeSinceLastRequest = now - lastRequestTime;\r\n\r\n            // Wait if needed\r\n            if (timeSinceLastRequest < currentDelay) {\r\n                await sleep(currentDelay - timeSinceLastRequest + addJitter(50));\r\n            }\r\n\r\n            lastRequestTime = Date.now();\r\n\r\n            try {\r\n                const result = await fn();\r\n\r\n                // Success - gradually reduce delay\r\n                consecutiveErrors = 0;\r\n                currentDelay = Math.max(minDelay, currentDelay * 0.9);\r\n\r\n                return result;\r\n            } catch (error) {\r\n                consecutiveErrors++;\r\n\r\n                // Increase delay on errors\r\n                currentDelay = Math.min(maxDelay, currentDelay * 2);\r\n\r\n                throw error;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Get current delay for monitoring\r\n         */\r\n        getCurrentDelay(): number {\r\n            return currentDelay;\r\n        },\r\n\r\n        /**\r\n         * Reset the queue state\r\n         */\r\n        reset(): void {\r\n            consecutiveErrors = 0;\r\n            currentDelay = Math.max(minDelay, delayPerRequest);\r\n            lastRequestTime = 0;\r\n        }\r\n    };\r\n}\r\n\r\ninterface BatchOptions<T, R> {\r\n    items: T[];\r\n    batchSize?: number;\r\n    delayBetweenBatches?: number;\r\n    onProgress?: (completed: number, total: number) => void;\r\n    processor: (item: T) => Promise<R>;\r\n}\r\n\r\n/**\r\n * Process items in batches with delays\r\n */\r\nexport async function processBatch<T, R>(options: BatchOptions<T, R>): Promise<R[]> {\r\n    const {\r\n        items,\r\n        batchSize = 10,\r\n        delayBetweenBatches = 2000,\r\n        onProgress,\r\n        processor\r\n    } = options;\r\n\r\n    const results: R[] = [];\r\n    const total = items.length;\r\n    let completed = 0;\r\n\r\n    // Split into batches\r\n    for (let i = 0; i < items.length; i += batchSize) {\r\n        const batch = items.slice(i, i + batchSize);\r\n\r\n        // Process batch concurrently\r\n        const batchResults = await Promise.all(\r\n            batch.map(async (item) => {\r\n                try {\r\n                    const result = await processor(item);\r\n                    completed++;\r\n\r\n                    if (onProgress) {\r\n                        onProgress(completed, total);\r\n                    }\r\n\r\n                    return result;\r\n                } catch (error) {\r\n                    completed++;\r\n                    console.error('Batch item failed:', error);\r\n                    return null as R;\r\n                }\r\n            })\r\n        );\r\n\r\n        results.push(...batchResults);\r\n\r\n        // Delay between batches (except for the last one)\r\n        if (i + batchSize < items.length) {\r\n            console.log(`Batch ${Math.floor(i / batchSize) + 1} complete. Waiting ${delayBetweenBatches}ms...`);\r\n            await sleep(addJitter(delayBetweenBatches));\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * Sequential processing with delay between each item\r\n * Better for strict rate limits\r\n */\r\nexport async function processSequentially<T, R>(\r\n    items: T[],\r\n    processor: (item: T) => Promise<R>,\r\n    delayBetweenItems: number = 200,\r\n    onProgress?: (completed: number, total: number) => void\r\n): Promise<R[]> {\r\n    const results: R[] = [];\r\n    const total = items.length;\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n        try {\r\n            const result = await processor(items[i]);\r\n            results.push(result);\r\n        } catch (error) {\r\n            console.error(`Item ${i} failed:`, error);\r\n            results.push(null as R);\r\n        }\r\n\r\n        if (onProgress) {\r\n            onProgress(i + 1, total);\r\n        }\r\n\r\n        // Delay between items (except for the last one)\r\n        if (i < items.length - 1) {\r\n            await sleep(addJitter(delayBetweenItems));\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n"],"names":[],"mappings":"AAAA,gCAAgC;AAChC,wEAAwE;AAExE;;CAEC;;;;;;;;;;;;;;;;AACM,SAAS,MAAM,EAAU;IAC5B,OAAO,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;AACtD;AAOO,SAAS,UAAU,SAAiB,EAAE,gBAAwB,GAAG;IACpE,MAAM,SAAS,YAAY,gBAAgB,CAAC,KAAK,MAAM,KAAK,IAAI,CAAC;IACjE,OAAO,KAAK,GAAG,CAAC,GAAG,YAAY;AACnC;AAQO,SAAS,mBAAmB,OAAe,EAAE,YAAoB,IAAI,EAAE,WAAmB,KAAK;IAClG,MAAM,QAAQ,KAAK,GAAG,CAAC,YAAY,KAAK,GAAG,CAAC,GAAG,UAAU;IACzD,OAAO,UAAU;AACrB;AAYO,eAAe,UAClB,EAAoB,EACpB,UAAwB,CAAC,CAAC;IAE1B,MAAM,EACF,aAAa,CAAC,EACd,YAAY,IAAI,EAChB,WAAW,KAAK,EAChB,OAAO,EACV,GAAG;IAEJ,IAAI,YAA0B;IAE9B,IAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAAW;QACpD,IAAI;YACA,OAAO,MAAM;QACjB,EAAE,OAAO,OAAO;YACZ,YAAY;YAEZ,yCAAyC;YACzC,MAAM,cAAc,iBAAiB,SACjC,CAAC,MAAM,OAAO,CAAC,QAAQ,CAAC,UAAU,MAAM,OAAO,CAAC,QAAQ,CAAC,aAAa;YAE1E,IAAI,UAAU,YAAY;gBACtB,MAAM,QAAQ,cACR,mBAAmB,SAAS,YAAY,GAAG,UAAU,+BAA+B;mBACpF,mBAAmB,SAAS,WAAW;gBAE7C,IAAI,SAAS;oBACT,QAAQ,UAAU,GAAG,WAAW;gBACpC;gBAEA,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,UAAU,EAAE,CAAC,EAAE,WAAW,OAAO,EAAE,MAAM,KAAK,CAAC;gBACpE,MAAM,MAAM;YAChB;QACJ;IACJ;IAEA,MAAM;AACV;AAWO,SAAS,qBAAqB,UAA2B,CAAC,CAAC;IAC9D,MAAM,EACF,WAAW,GAAG,EACd,WAAW,IAAI,EACf,oBAAoB,CAAC,EACxB,GAAG;IAEJ,MAAM,kBAAkB,OAAO;IAC/B,IAAI,kBAAkB;IACtB,IAAI,oBAAoB;IACxB,IAAI,eAAe,KAAK,GAAG,CAAC,UAAU;IAEtC,OAAO;QACH;;SAEC,GACD,MAAM,SAAW,EAAoB;YACjC,oCAAoC;YACpC,MAAM,MAAM,KAAK,GAAG;YACpB,MAAM,uBAAuB,MAAM;YAEnC,iBAAiB;YACjB,IAAI,uBAAuB,cAAc;gBACrC,MAAM,MAAM,eAAe,uBAAuB,UAAU;YAChE;YAEA,kBAAkB,KAAK,GAAG;YAE1B,IAAI;gBACA,MAAM,SAAS,MAAM;gBAErB,mCAAmC;gBACnC,oBAAoB;gBACpB,eAAe,KAAK,GAAG,CAAC,UAAU,eAAe;gBAEjD,OAAO;YACX,EAAE,OAAO,OAAO;gBACZ;gBAEA,2BAA2B;gBAC3B,eAAe,KAAK,GAAG,CAAC,UAAU,eAAe;gBAEjD,MAAM;YACV;QACJ;QAEA;;SAEC,GACD;YACI,OAAO;QACX;QAEA;;SAEC,GACD;YACI,oBAAoB;YACpB,eAAe,KAAK,GAAG,CAAC,UAAU;YAClC,kBAAkB;QACtB;IACJ;AACJ;AAaO,eAAe,aAAmB,OAA2B;IAChE,MAAM,EACF,KAAK,EACL,YAAY,EAAE,EACd,sBAAsB,IAAI,EAC1B,UAAU,EACV,SAAS,EACZ,GAAG;IAEJ,MAAM,UAAe,EAAE;IACvB,MAAM,QAAQ,MAAM,MAAM;IAC1B,IAAI,YAAY;IAEhB,qBAAqB;IACrB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,UAAW;QAC9C,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAG,IAAI;QAEjC,6BAA6B;QAC7B,MAAM,eAAe,MAAM,QAAQ,GAAG,CAClC,MAAM,GAAG,CAAC,OAAO;YACb,IAAI;gBACA,MAAM,SAAS,MAAM,UAAU;gBAC/B;gBAEA,IAAI,YAAY;oBACZ,WAAW,WAAW;gBAC1B;gBAEA,OAAO;YACX,EAAE,OAAO,OAAO;gBACZ;gBACA,QAAQ,KAAK,CAAC,sBAAsB;gBACpC,OAAO;YACX;QACJ;QAGJ,QAAQ,IAAI,IAAI;QAEhB,kDAAkD;QAClD,IAAI,IAAI,YAAY,MAAM,MAAM,EAAE;YAC9B,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,KAAK,CAAC,IAAI,aAAa,EAAE,mBAAmB,EAAE,oBAAoB,KAAK,CAAC;YAClG,MAAM,MAAM,UAAU;QAC1B;IACJ;IAEA,OAAO;AACX;AAMO,eAAe,oBAClB,KAAU,EACV,SAAkC,EAClC,oBAA4B,GAAG,EAC/B,UAAuD;IAEvD,MAAM,UAAe,EAAE;IACvB,MAAM,QAAQ,MAAM,MAAM;IAE1B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACnC,IAAI;YACA,MAAM,SAAS,MAAM,UAAU,KAAK,CAAC,EAAE;YACvC,QAAQ,IAAI,CAAC;QACjB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE,QAAQ,CAAC,EAAE;YACnC,QAAQ,IAAI,CAAC;QACjB;QAEA,IAAI,YAAY;YACZ,WAAW,IAAI,GAAG;QACtB;QAEA,gDAAgD;QAChD,IAAI,IAAI,MAAM,MAAM,GAAG,GAAG;YACtB,MAAM,MAAM,UAAU;QAC1B;IACJ;IAEA,OAAO;AACX"}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/fingerprint.ts"],"sourcesContent":["// Request Fingerprint Spoofing\r\n// Makes each request look like it's from a different person/device\r\n\r\n// Realistic User-Agent strings from different devices/browsers\r\nconst USER_AGENTS = [\r\n    // Chrome Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',\r\n    // Firefox Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0',\r\n    // Chrome Mac\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',\r\n    // Safari Mac\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',\r\n    // Edge Windows\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',\r\n    // Chrome Linux\r\n    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    // Mobile Chrome Android\r\n    'Mozilla/5.0 (Linux; Android 14; SM-S918B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.144 Mobile Safari/537.36',\r\n    'Mozilla/5.0 (Linux; Android 13; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.144 Mobile Safari/537.36',\r\n    // Mobile Safari iPhone\r\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',\r\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1',\r\n    // iPad\r\n    'Mozilla/5.0 (iPad; CPU OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',\r\n];\r\n\r\n// Accept-Language headers from different countries\r\nconst ACCEPT_LANGUAGES = [\r\n    'en-US,en;q=0.9',\r\n    'en-GB,en;q=0.9',\r\n    'en-US,en;q=0.9,es;q=0.8',\r\n    'en-US,en;q=0.9,fr;q=0.8',\r\n    'tr-TR,tr;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'es-ES,es;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'pl-PL,pl;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'nl-NL,nl;q=0.9,en-US;q=0.8,en;q=0.7',\r\n    'it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7',\r\n];\r\n\r\n// Accept header variations\r\nconst ACCEPT_HEADERS = [\r\n    'application/json, text/plain, */*',\r\n    'application/json',\r\n    '*/*',\r\n    'application/json, text/javascript, */*; q=0.01',\r\n];\r\n\r\n// Sec-Fetch headers (modern browsers)\r\nconst SEC_FETCH_MODES = ['cors', 'no-cors', 'navigate'];\r\nconst SEC_FETCH_SITES = ['cross-site', 'same-origin', 'same-site', 'none'];\r\nconst SEC_FETCH_DESTS = ['document', 'empty', 'script'];\r\n\r\n// Cache-Control variations\r\nconst CACHE_CONTROLS = [\r\n    'no-cache',\r\n    'max-age=0',\r\n    'no-store',\r\n    undefined, // Some requests don't have this header\r\n];\r\n\r\n// Connection header variations\r\nconst CONNECTIONS = ['keep-alive', undefined];\r\n\r\n// Referer URLs (Roblox-related)\r\nconst REFERERS = [\r\n    'https://www.roblox.com/',\r\n    'https://www.roblox.com/users/profile',\r\n    'https://www.roblox.com/games',\r\n    'https://www.roblox.com/discover',\r\n    'https://www.roblox.com/home',\r\n    undefined, // Some requests don't have referer\r\n];\r\n\r\n/**\r\n * Get a random element from an array\r\n */\r\nfunction randomFrom<T>(arr: T[]): T {\r\n    return arr[Math.floor(Math.random() * arr.length)];\r\n}\r\n\r\n/**\r\n * Generate random fingerprint headers to mimic a real user\r\n */\r\nexport function generateRandomHeaders(): Record<string, string> {\r\n    const headers: Record<string, string> = {};\r\n\r\n    // Core headers - always include\r\n    headers['User-Agent'] = randomFrom(USER_AGENTS);\r\n    headers['Accept-Language'] = randomFrom(ACCEPT_LANGUAGES);\r\n    headers['Accept'] = randomFrom(ACCEPT_HEADERS);\r\n\r\n    // Optional headers - include randomly\r\n    const cacheControl = randomFrom(CACHE_CONTROLS);\r\n    if (cacheControl) {\r\n        headers['Cache-Control'] = cacheControl;\r\n    }\r\n\r\n    const connection = randomFrom(CONNECTIONS);\r\n    if (connection) {\r\n        headers['Connection'] = connection;\r\n    }\r\n\r\n    const referer = randomFrom(REFERERS);\r\n    if (referer) {\r\n        headers['Referer'] = referer;\r\n    }\r\n\r\n    // Sec-Fetch headers (50% chance to include - not all browsers send these)\r\n    if (Math.random() > 0.5) {\r\n        headers['Sec-Fetch-Mode'] = randomFrom(SEC_FETCH_MODES);\r\n        headers['Sec-Fetch-Site'] = randomFrom(SEC_FETCH_SITES);\r\n        headers['Sec-Fetch-Dest'] = randomFrom(SEC_FETCH_DESTS);\r\n    }\r\n\r\n    // DNT (Do Not Track) - random\r\n    if (Math.random() > 0.7) {\r\n        headers['DNT'] = '1';\r\n    }\r\n\r\n    // Upgrade-Insecure-Requests - random (usually for navigation)\r\n    if (Math.random() > 0.8) {\r\n        headers['Upgrade-Insecure-Requests'] = '1';\r\n    }\r\n\r\n    return headers;\r\n}\r\n\r\n/**\r\n * Generate random delay with human-like variation\r\n * Humans don't click at exact intervals - there's natural variation\r\n */\r\nexport function getHumanLikeDelay(baseDelay: number = 500): number {\r\n    // Add random jitter: 70-130% of base delay\r\n    const jitterMultiplier = 0.7 + (Math.random() * 0.6);\r\n    const delay = Math.round(baseDelay * jitterMultiplier);\r\n\r\n    // Occasionally add longer pause (like a human reading)\r\n    if (Math.random() > 0.9) {\r\n        return delay + Math.round(Math.random() * 2000); // Extra 0-2 seconds\r\n    }\r\n\r\n    return delay;\r\n}\r\n\r\n/**\r\n * Generate a unique request ID (some APIs track this)\r\n */\r\nexport function generateRequestId(): string {\r\n    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\r\n    let id = '';\r\n    for (let i = 0; i < 32; i++) {\r\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return id;\r\n}\r\n\r\n/**\r\n * Get current timestamp with slight randomization\r\n * (Some fingerprinting tracks exact request timing)\r\n */\r\nexport function getRandomizedTimestamp(): number {\r\n    return Date.now() + Math.floor(Math.random() * 1000) - 500;\r\n}\r\n\r\n/**\r\n * Generate a browser tracker ID (required by some Roblox API endpoints)\r\n * Format: Large numeric value that Roblox uses to track browser sessions\r\n * Example: 65445383610\r\n */\r\nexport function generateBrowserTrackerId(): string {\r\n    // Generate a large random number (10-12 digits like real Roblox tracker IDs)\r\n    const min = 10000000000; // 10 billion\r\n    const max = 99999999999; // ~100 billion\r\n    return String(Math.floor(Math.random() * (max - min) + min));\r\n}\r\n\r\n/**\r\n * Generate Roblox-specific headers that match what a real browser sends\r\n * Based on actual captured request from Chrome 143 (February 2026)\r\n * These headers closely match the format seen in real blocking requests\r\n */\r\nexport function generateRobloxHeaders(): Record<string, string> {\r\n    const browserTrackerId = generateBrowserTrackerId();\r\n    const acceptLanguage = randomFrom(ACCEPT_LANGUAGES);\r\n\r\n    return {\r\n        'Accept': 'application/json, text/plain, */*',\r\n        'Accept-Encoding': 'gzip, deflate, br',\r\n        'Accept-Language': acceptLanguage,\r\n        'Origin': 'https://www.roblox.com',\r\n        'Referer': 'https://www.roblox.com/',\r\n        'Priority': 'u=1, i',\r\n        'Sec-Ch-Ua': '\"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"',\r\n        'Sec-Ch-Ua-Mobile': '?0',\r\n        'Sec-Ch-Ua-Platform': '\"Windows\"',\r\n        'Sec-Fetch-Dest': 'empty',\r\n        'Sec-Fetch-Mode': 'cors',\r\n        'Sec-Fetch-Site': 'same-site',\r\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36',\r\n        'x-browser-tracker-id': browserTrackerId,\r\n    };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/roblox.ts"],"sourcesContent":["// Roblox API client for friend request operations\r\n// With fingerprint spoofing for undetected requests and HBA token generation\r\nimport { HttpsProxyAgent } from 'https-proxy-agent';\r\nimport { HBAClient } from 'roblox-bat';\r\nimport { withRetry, sleep, addJitter } from './rate-limiter';\r\nimport { generateRandomHeaders, getHumanLikeDelay, generateBrowserTrackerId, generateRobloxHeaders } from './fingerprint';\r\n\r\ninterface RobloxUser {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n    created: string;\r\n    isBanned: boolean;\r\n}\r\n\r\ninterface FriendRequest {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n    created: string;\r\n}\r\n\r\n// Helper to create fetch options with optional HTTP proxy and fingerprint spoofing\r\nfunction getFetchOptions(customHeaders: Record<string, string>, httpProxy?: string, spoof: boolean = false): RequestInit {\r\n    // Start with random fingerprint headers if spoofing is enabled\r\n    const headers: Record<string, string> = spoof ? { ...generateRandomHeaders() } : {};\r\n\r\n    // Add custom headers (these override fingerprint headers if needed)\r\n    Object.assign(headers, customHeaders);\r\n\r\n    const options: RequestInit = { headers };\r\n\r\n    if (httpProxy) {\r\n        // @ts-ignore - agent is valid for node-fetch\r\n        options.agent = new HttpsProxyAgent(httpProxy);\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n// Use direct Roblox API instead of roproxy when using HTTP proxy\r\n// This is more \"undetected\" because roproxy itself might be flagged\r\nfunction getApiUrl(service: string, path: string, useDirectApi: boolean = false): string {\r\n    if (useDirectApi) {\r\n        // Direct Roblox API\r\n        return `https://${service}.roblox.com${path}`;\r\n    }\r\n    // roproxy (fallback for when no HTTP proxy is provided)\r\n    return `https://${service}.roproxy.com${path}`;\r\n}\r\n\r\n// Delay between paginated requests\r\nconst PAGE_DELAY_MS = 500;\r\n\r\nexport async function getFriendRequests(cookie: string, httpProxy?: string): Promise<FriendRequest[]> {\r\n    const allRequests: FriendRequest[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 10; // Safety limit: 10 pages * 100 = 1000 max requests\r\n    const useDirectApi = !!httpProxy; // Use direct API if proxy is available\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', '/v1/my/friends/requests', useDirectApi)}?limit=100&sortOrder=Desc&cursor=${cursor}`\r\n            : `${getApiUrl('friends', '/v1/my/friends/requests', useDirectApi)}?limit=100&sortOrder=Desc`;\r\n\r\n        console.log(`Fetching friend requests page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        // Use retry logic for each page\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch friend requests: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const requests = data.data || [];\r\n        allRequests.push(...requests);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${requests.length} requests, total: ${allRequests.length}`);\r\n\r\n        // Add human-like delay between pages\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allRequests.length} total friend requests`);\r\n    return allRequests;\r\n}\r\n\r\n// Delay between getUserInfo calls - minimal with fingerprint spoofing\r\nconst USER_INFO_DELAY_MS = 100;\r\nlet lastUserInfoCall = 0;\r\n\r\nexport async function getUserInfo(userId: number, httpProxy?: string): Promise<RobloxUser | null> {\r\n    // Throttle getUserInfo calls with human-like timing\r\n    const now = Date.now();\r\n    const timeSinceLastCall = now - lastUserInfoCall;\r\n    const requiredDelay = getHumanLikeDelay(USER_INFO_DELAY_MS);\r\n\r\n    if (timeSinceLastCall < requiredDelay) {\r\n        await sleep(requiredDelay - timeSinceLastCall);\r\n    }\r\n    lastUserInfoCall = Date.now();\r\n\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({}, httpProxy, true); // Enable spoofing\r\n\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(\r\n                getApiUrl('users', `/v1/users/${userId}`, useDirectApi),\r\n                options\r\n            );\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                console.log('getUserInfo failed for userId:', userId, 'status:', response.status);\r\n                return null;\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 2,\r\n            baseDelay: 1000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`getUserInfo(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error fetching user info:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCSRFToken(cookie: string, httpProxy?: string): Promise<string | null> {\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        const response = await fetch(getApiUrl('auth', '/v2/logout', useDirectApi), {\r\n            ...options,\r\n            method: 'POST',\r\n        });\r\n\r\n        return response.headers.get('x-csrf-token');\r\n    } catch (error) {\r\n        console.error('Error getting CSRF token:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function acceptFriendRequest(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/accept-friend-request`, useDirectApi);\r\n    console.log(`Accepting friend request for user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true); // Enable spoofing\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Accept failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully accepted friend request from ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Accept(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error accepting friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function declineFriendRequest(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/decline-friend-request`, useDirectApi);\r\n    console.log(`Declining friend request for user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true); // Enable spoofing\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Decline failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully declined friend request from ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Decline(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error declining friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\n/**\r\n * Decline ALL pending friend requests at once using Roblox's native bulk endpoint\r\n * This is much faster than declining one by one\r\n */\r\nexport async function declineAllFriendRequests(cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', '/v1/user/friend-requests/decline-all', useDirectApi);\r\n    console.log(`Declining ALL friend requests... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Decline-all failed: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log('Successfully declined ALL friend requests');\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Decline-all retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error declining all friend requests:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function blockUser(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    // Use direct Roblox API when proxy is available, otherwise fall back to roproxy\r\n    const useDirectApi = !!httpProxy;\r\n    const baseHost = useDirectApi ? 'apis.roblox.com' : 'apis.roproxy.com';\r\n    const url = `https://${baseHost}/user-blocking-api/v1/users/${userId}/block-user`;\r\n\r\n    console.log(`Blocking user ${userId}... (${useDirectApi ? 'DIRECT API via proxy' : 'roproxy'})`);\r\n\r\n    // Generate Roblox-specific headers\r\n    const robloxHeaders = generateRobloxHeaders();\r\n    const acceptLanguage = robloxHeaders['Accept-Language'];\r\n    const userAgent = robloxHeaders['User-Agent'];\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            // Step 1: Generate HBA token using roblox-bat library\r\n            // This creates proper ECDSA P-256 signed tokens\r\n            let hbaHeaders: Record<string, string> = {};\r\n\r\n            try {\r\n                // Generate a fresh key pair for this session\r\n                const keys = await crypto.subtle.generateKey(\r\n                    { name: 'ECDSA', namedCurve: 'P-256' },\r\n                    false,\r\n                    ['sign']\r\n                );\r\n\r\n                const hbaClient = new HBAClient({\r\n                    keys,\r\n                    cookie: `.ROBLOSECURITY=${cookie}`,\r\n                });\r\n\r\n                // Generate the x-bound-auth-token for this request\r\n                // The blocking API uses POST with empty body\r\n                hbaHeaders = await hbaClient.generateBaseHeaders(\r\n                    `https://apis.roblox.com/user-blocking-api/v1/users/${userId}/block-user`,\r\n                    'POST',\r\n                    true, // authenticated\r\n                    ''    // empty body\r\n                );\r\n\r\n                console.log(`HBA token generated for user ${userId}`);\r\n            } catch (hbaError) {\r\n                console.warn(`HBA token generation failed: ${hbaError}, continuing without it`);\r\n            }\r\n\r\n            // Step 2: Send POST request with all headers\r\n            // Generate a browser tracker ID for the request\r\n            const browserTrackerId = generateBrowserTrackerId();\r\n\r\n            // Build full cookie string with tracking cookies\r\n            // The browserid in RBXEventTrackerV2 must match x-browser-tracker-id\r\n            const now = new Date();\r\n            const createDate = `${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')}/${now.getFullYear()} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;\r\n            const sessionId = crypto.randomUUID();\r\n            const rbxId = Math.floor(Math.random() * 9000000000) + 1000000000; // Random 10-digit number\r\n\r\n            const fullCookie = [\r\n                `RBXSessionTracker=sessionid=${sessionId}`,\r\n                `RBXEventTrackerV2=CreateDate=${encodeURIComponent(createDate)}&rbxid=${rbxId}&browserid=${browserTrackerId}`,\r\n                `.ROBLOSECURITY=${cookie}`,\r\n            ].join('; ');\r\n\r\n            const postOptions = getFetchOptions({\r\n                'Content-Length': '0',\r\n                'Sec-Ch-Ua-Platform': '\"Windows\"',\r\n                'X-CSRF-TOKEN': csrfToken,\r\n                'Accept-Language': acceptLanguage,\r\n                'Sec-Ch-Ua': '\"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"',\r\n                'Sec-Ch-Ua-Mobile': '?0',\r\n                'x-browser-tracker-id': browserTrackerId,\r\n                ...hbaHeaders, // Adds x-bound-auth-token if generated\r\n                'Accept': 'application/json, text/plain, */*',\r\n                'User-Agent': userAgent,\r\n                'Origin': 'https://www.roblox.com',\r\n                'Sec-Fetch-Site': 'same-site',\r\n                'Sec-Fetch-Mode': 'cors',\r\n                'Sec-Fetch-Dest': 'empty',\r\n                'Referer': 'https://www.roblox.com/',\r\n                'Accept-Encoding': 'gzip, deflate, br',\r\n                'Priority': 'u=1, i',\r\n                'Cookie': fullCookie,\r\n            }, httpProxy, false);\r\n\r\n            const response = await fetch(url, {\r\n                ...postOptions,\r\n                method: 'POST',\r\n                body: '',\r\n            });\r\n\r\n            console.log(`Block response for ${userId}: status=${response.status} (proxy: ${httpProxy ? 'yes' : 'no'})`);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            let responseBody: string | null = null;\r\n            try {\r\n                responseBody = await response.text();\r\n            } catch {\r\n                responseBody = null;\r\n            }\r\n\r\n            if (!response.ok) {\r\n                console.error(`Block failed for ${userId}: HTTP ${response.status}`);\r\n                console.error(`Response body: ${responseBody || '(empty)'}`);\r\n\r\n                if (responseBody) {\r\n                    try {\r\n                        const errorData = JSON.parse(responseBody);\r\n                        if (errorData.errors?.[0]?.message) {\r\n                            return { success: false, error: errorData.errors[0].message };\r\n                        }\r\n                    } catch {\r\n                        // Not JSON\r\n                    }\r\n                }\r\n\r\n                return { success: false, error: `HTTP ${response.status}: ${responseBody || 'Unknown error'}` };\r\n            }\r\n\r\n            console.log(`Successfully blocked user ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 2,\r\n            baseDelay: 3000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Block(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error blocking user:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\nexport async function unfriendUser(userId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${userId}/unfriend`, useDirectApi);\r\n    console.log(`Unfriending user ${userId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                console.error(`Unfriend failed for ${userId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully unfriended user ${userId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Unfriend(${userId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error unfriending user:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\ninterface Friend {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n}\r\n\r\nexport async function getFriends(cookie: string, httpProxy?: string): Promise<Friend[]> {\r\n    const allFriends: Friend[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 20; // Safety limit: 20 pages * 100 = 2000 max friends\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', '/v1/my/friends', useDirectApi)}?limit=100&cursor=${cursor}`\r\n            : `${getApiUrl('friends', '/v1/my/friends', useDirectApi)}?limit=100`;\r\n\r\n        console.log(`Fetching friends page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true);\r\n\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch friends: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Friends page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const friends = data.data || [];\r\n        allFriends.push(...friends);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${friends.length} friends, total: ${allFriends.length}`);\r\n\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allFriends.length} total friends`);\r\n    return allFriends;\r\n}\r\n\r\nexport function getAccountAgeInDays(created: string): number {\r\n    const createdDate = new Date(created);\r\n    const now = new Date();\r\n    const diffTime = Math.abs(now.getTime() - createdDate.getTime());\r\n    return Math.floor(diffTime / (1000 * 60 * 60 * 24));\r\n}\r\n\r\nexport async function getAuthenticatedUser(cookie: string, httpProxy?: string): Promise<{ id: number; name: string } | null> {\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    try {\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true); // Enable spoofing\r\n\r\n        const response = await fetch(getApiUrl('users', '/v1/users/authenticated', useDirectApi), options);\r\n\r\n        if (!response.ok) {\r\n            return null;\r\n        }\r\n\r\n        const data = await response.json();\r\n        return { id: data.id, name: data.name };\r\n    } catch (error) {\r\n        console.error('Error getting authenticated user:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Helper to get avatar thumbnail URL\r\nexport function getAvatarUrl(userId: number): string {\r\n    return `https://thumbnails.roproxy.com/v1/users/avatar-headshot?userIds=${userId}&size=48x48&format=Png&isCircular=false`;\r\n}\r\n\r\ninterface Follower {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n}\r\n\r\n/**\r\n * Get all followers of a user\r\n */\r\nexport async function getFollowers(userId: number, cookie: string, httpProxy?: string): Promise<Follower[]> {\r\n    const allFollowers: Follower[] = [];\r\n    let cursor: string | null = null;\r\n    let pageCount = 0;\r\n    const maxPages = 50; // Safety limit: 50 pages * 100 = 5000 max followers\r\n    const useDirectApi = !!httpProxy;\r\n\r\n    do {\r\n        const url: string = cursor\r\n            ? `${getApiUrl('friends', `/v1/users/${userId}/followers`, useDirectApi)}?limit=100&cursor=${cursor}`\r\n            : `${getApiUrl('friends', `/v1/users/${userId}/followers`, useDirectApi)}?limit=100`;\r\n\r\n        console.log(`Fetching followers page ${pageCount + 1}... (${useDirectApi ? 'DIRECT API' : 'roproxy'})`);\r\n\r\n        const options = getFetchOptions({\r\n            'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        }, httpProxy, true);\r\n\r\n        const data = await withRetry(async () => {\r\n            const response = await fetch(url, options);\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch followers: ${response.status}`);\r\n            }\r\n\r\n            return response.json();\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 2000,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`Followers page ${pageCount + 1} retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        const followers = data.data || [];\r\n        allFollowers.push(...followers);\r\n\r\n        cursor = data.nextPageCursor || null;\r\n        pageCount++;\r\n\r\n        console.log(`Page ${pageCount}: Got ${followers.length} followers, total: ${allFollowers.length}`);\r\n\r\n        if (cursor) {\r\n            await sleep(getHumanLikeDelay(PAGE_DELAY_MS));\r\n        }\r\n\r\n    } while (cursor && pageCount < maxPages);\r\n\r\n    console.log(`Fetched ${allFollowers.length} total followers`);\r\n    return allFollowers;\r\n}\r\n\r\n/**\r\n * Send a friend request to a user\r\n */\r\nexport async function sendFriendRequest(targetUserId: number, cookie: string, csrfToken: string, httpProxy?: string): Promise<{ success: boolean; error?: string }> {\r\n    const useDirectApi = !!httpProxy;\r\n    const url = getApiUrl('friends', `/v1/users/${targetUserId}/request-friendship`, useDirectApi);\r\n    console.log(`Sending friend request to user ${targetUserId}... (${useDirectApi ? 'DIRECT' : 'roproxy'})`);\r\n\r\n    const options = getFetchOptions({\r\n        'Cookie': `.ROBLOSECURITY=${cookie}`,\r\n        'X-CSRF-TOKEN': csrfToken,\r\n        'Content-Type': 'application/json',\r\n    }, httpProxy, true);\r\n\r\n    try {\r\n        const result = await withRetry(async () => {\r\n            const response = await fetch(url, {\r\n                ...options,\r\n                method: 'POST',\r\n            });\r\n\r\n            if (response.status === 429) {\r\n                throw new Error('Rate limited (429)');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                const errorText = await response.text();\r\n                // Check for \"already friends\" or \"pending\" errors\r\n                if (errorText.includes('AlreadyFriends') || errorText.includes('PendingFriendRequest')) {\r\n                    console.log(`Already friends or pending with ${targetUserId}`);\r\n                    return { success: true, skipped: true };\r\n                }\r\n                console.error(`Friend request failed for ${targetUserId}: ${response.status} - ${errorText}`);\r\n                return { success: false, error: `HTTP ${response.status}: ${errorText}` };\r\n            }\r\n\r\n            console.log(`Successfully sent friend request to ${targetUserId}`);\r\n            return { success: true };\r\n        }, {\r\n            maxRetries: 3,\r\n            baseDelay: 1500,\r\n            onRetry: (attempt, error, delay) => {\r\n                console.log(`FriendRequest(${targetUserId}) retry ${attempt}: ${error.message}, waiting ${delay}ms`);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error sending friend request:', error);\r\n        return { success: false, error: String(error) };\r\n    }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/bot-detector.ts"],"sourcesContent":["import { supabase } from './supabase';\r\nimport { getAccountAgeInDays } from './roblox';\r\n\r\ninterface BotDetectionResult {\r\n    isBot: boolean;\r\n    reason: string | null;\r\n    score: number;\r\n}\r\n\r\ninterface UserInfo {\r\n    id: number;\r\n    name: string;\r\n    displayName: string;\r\n    created: string;\r\n    isBanned: boolean;\r\n}\r\n\r\n// Account age threshold in days (2 months  60 days)\r\nconst MIN_ACCOUNT_AGE_DAYS = 60;\r\n\r\n// Random username patterns (common bot patterns)\r\nconst RANDOM_USERNAME_PATTERNS = [\r\n    /^[a-z]{3,5}\\d{4,8}$/i,           // abc12345\r\n    /^[A-Z][a-z]{2,4}\\d{5,}$/,        // Abc12345678\r\n    /^user\\d{6,}$/i,                   // user123456\r\n    /^player\\d{5,}$/i,                 // player12345\r\n    /^\\d{10,}$/,                       // Just numbers\r\n];\r\n\r\n// detectBot now accepts userInfo directly to avoid duplicate API calls\r\nexport async function detectBot(userId: number, username: string, userInfo?: UserInfo | null): Promise<BotDetectionResult> {\r\n    let score = 0;\r\n    const reasons: string[] = [];\r\n\r\n    // Handle undefined/null username\r\n    if (!username) {\r\n        return {\r\n            isBot: false,\r\n            reason: 'Username not available',\r\n            score: 0,\r\n        };\r\n    }\r\n\r\n    // Check blacklist first (critical) - match by username OR user ID\r\n    const { data: blacklisted } = await supabase\r\n        .from('roblox_blacklist')\r\n        .select('*')\r\n        .or(`username.eq.${username.toLowerCase()},roblox_user_id.eq.${userId}`)\r\n        .limit(1)\r\n        .maybeSingle();\r\n\r\n    if (blacklisted) {\r\n        return {\r\n            isBot: true,\r\n            reason: `Blacklisted: ${blacklisted.reason || 'No reason given'}`,\r\n            score: 100,\r\n        };\r\n    }\r\n\r\n    // Use provided userInfo for account age check\r\n    if (userInfo) {\r\n        // Check account age (high weight)\r\n        const accountAge = getAccountAgeInDays(userInfo.created);\r\n        if (accountAge < MIN_ACCOUNT_AGE_DAYS) {\r\n            score += 60;\r\n            reasons.push(`Account only ${accountAge} days old`);\r\n        } else if (accountAge < 90) {\r\n            score += 20;\r\n            reasons.push(`Account ${accountAge} days old`);\r\n        }\r\n\r\n        // Check if banned (shouldn't happen but just in case)\r\n        if (userInfo.isBanned) {\r\n            score += 100;\r\n            reasons.push('Account is banned');\r\n        }\r\n    } else {\r\n        // If no userInfo available, add some suspicion\r\n        score += 10;\r\n        reasons.push('Could not verify account info');\r\n    }\r\n\r\n    // Check for random username patterns (medium weight)\r\n    for (const pattern of RANDOM_USERNAME_PATTERNS) {\r\n        if (pattern.test(username)) {\r\n            score += 25;\r\n            reasons.push('Username matches bot pattern');\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Determine if bot based on score\r\n    // Score >= 50 is considered a bot\r\n    const isBot = score >= 50;\r\n\r\n    return {\r\n        isBot,\r\n        reason: reasons.length > 0 ? reasons.join(', ') : null,\r\n        score,\r\n    };\r\n}\r\n\r\nexport async function addToBlacklist(username: string, reason: string | null, addedBy: string) {\r\n    const { data, error } = await supabase\r\n        .from('roblox_blacklist')\r\n        .upsert({\r\n            username: username.toLowerCase(),\r\n            reason,\r\n            added_by: addedBy,\r\n        }, { onConflict: 'username' })\r\n        .select()\r\n        .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n}\r\n\r\nexport async function removeFromBlacklist(username: string) {\r\n    const { error } = await supabase\r\n        .from('roblox_blacklist')\r\n        .delete()\r\n        .eq('username', username.toLowerCase());\r\n\r\n    if (error) throw error;\r\n}\r\n\r\nexport async function getBlacklist() {\r\n    const { data } = await supabase\r\n        .from('roblox_blacklist')\r\n        .select('*')\r\n        .order('created_at', { ascending: false });\r\n\r\n    return data || [];\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAgBA,qDAAqD;AACrD,MAAM,uBAAuB;AAE7B,iDAAiD;AACjD,MAAM,2BAA2B;IAC7B;IACA;IACA;IACA;IACA;CACH;AAGM,eAAe,UAAU,MAAc,EAAE,QAAgB,EAAE,QAA0B;IACxF,IAAI,QAAQ;IACZ,MAAM,UAAoB,EAAE;IAE5B,iCAAiC;IACjC,IAAI,CAAC,UAAU;QACX,OAAO;YACH,OAAO;YACP,QAAQ;YACR,OAAO;QACX;IACJ;IAEA,kEAAkE;IAClE,MAAM,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,oIAAQ,CACvC,IAAI,CAAC,oBACL,MAAM,CAAC,KACP,EAAE,CAAC,CAAC,YAAY,EAAE,SAAS,WAAW,GAAG,mBAAmB,EAAE,QAAQ,EACtE,KAAK,CAAC,GACN,WAAW;IAEhB,IAAI,aAAa;QACb,OAAO;YACH,OAAO;YACP,QAAQ,CAAC,aAAa,EAAE,YAAY,MAAM,IAAI,mBAAmB;YACjE,OAAO;QACX;IACJ;IAEA,8CAA8C;IAC9C,IAAI,UAAU;QACV,kCAAkC;QAClC,MAAM,aAAa,IAAA,6IAAmB,EAAC,SAAS,OAAO;QACvD,IAAI,aAAa,sBAAsB;YACnC,SAAS;YACT,QAAQ,IAAI,CAAC,CAAC,aAAa,EAAE,WAAW,SAAS,CAAC;QACtD,OAAO,IAAI,aAAa,IAAI;YACxB,SAAS;YACT,QAAQ,IAAI,CAAC,CAAC,QAAQ,EAAE,WAAW,SAAS,CAAC;QACjD;QAEA,sDAAsD;QACtD,IAAI,SAAS,QAAQ,EAAE;YACnB,SAAS;YACT,QAAQ,IAAI,CAAC;QACjB;IACJ,OAAO;QACH,+CAA+C;QAC/C,SAAS;QACT,QAAQ,IAAI,CAAC;IACjB;IAEA,qDAAqD;IACrD,KAAK,MAAM,WAAW,yBAA0B;QAC5C,IAAI,QAAQ,IAAI,CAAC,WAAW;YACxB,SAAS;YACT,QAAQ,IAAI,CAAC;YACb;QACJ;IACJ;IAEA,kCAAkC;IAClC,kCAAkC;IAClC,MAAM,QAAQ,SAAS;IAEvB,OAAO;QACH;QACA,QAAQ,QAAQ,MAAM,GAAG,IAAI,QAAQ,IAAI,CAAC,QAAQ;QAClD;IACJ;AACJ;AAEO,eAAe,eAAe,QAAgB,EAAE,MAAqB,EAAE,OAAe;IACzF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CACjC,IAAI,CAAC,oBACL,MAAM,CAAC;QACJ,UAAU,SAAS,WAAW;QAC9B;QACA,UAAU;IACd,GAAG;QAAE,YAAY;IAAW,GAC3B,MAAM,GACN,MAAM;IAEX,IAAI,OAAO,MAAM;IACjB,OAAO;AACX;AAEO,eAAe,oBAAoB,QAAgB;IACtD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CAC3B,IAAI,CAAC,oBACL,MAAM,GACN,EAAE,CAAC,YAAY,SAAS,WAAW;IAExC,IAAI,OAAO,MAAM;AACrB;AAEO,eAAe;IAClB,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,oBACL,MAAM,CAAC,KACP,KAAK,CAAC,cAAc;QAAE,WAAW;IAAM;IAE5C,OAAO,QAAQ,EAAE;AACrB"}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/proxy-pool.ts"],"sourcesContent":["// Proxy Pool - Manages multiple proxies with rotation\r\n\r\nexport interface ProxyPool {\r\n    getNext(): string | undefined;\r\n    getRandom(): string | undefined;\r\n    getAll(): string[];\r\n    size(): number;\r\n    markFailed(proxy: string): void;\r\n    markSuccess(proxy: string): void;\r\n}\r\n\r\ninterface ProxyStats {\r\n    failures: number;\r\n    successes: number;\r\n    lastUsed: number;\r\n}\r\n\r\n/**\r\n * Parse proxy list from various formats\r\n * Supports: newline-separated, comma-separated, JSON array\r\n */\r\nexport function parseProxyList(input: string | null | undefined): string[] {\r\n    if (!input || typeof input !== 'string') {\r\n        return [];\r\n    }\r\n\r\n    const trimmed = input.trim();\r\n\r\n    // Try JSON array first\r\n    if (trimmed.startsWith('[')) {\r\n        try {\r\n            const parsed = JSON.parse(trimmed);\r\n            if (Array.isArray(parsed)) {\r\n                return parsed.filter(p => typeof p === 'string' && p.trim()).map(p => p.trim());\r\n            }\r\n        } catch {\r\n            // Not valid JSON, continue\r\n        }\r\n    }\r\n\r\n    // Split by newlines or commas\r\n    const proxies = trimmed\r\n        .split(/[\\n,]+/)\r\n        .map(p => p.trim())\r\n        .filter(p => p.length > 0 && (p.startsWith('http://') || p.startsWith('https://') || p.includes('@')));\r\n\r\n    return proxies;\r\n}\r\n\r\n/**\r\n * Create a proxy pool with rotation and failure tracking\r\n */\r\nexport function createProxyPool(proxies: string[]): ProxyPool {\r\n    const stats = new Map<string, ProxyStats>();\r\n    let currentIndex = 0;\r\n\r\n    // Initialize stats for all proxies\r\n    proxies.forEach(proxy => {\r\n        stats.set(proxy, { failures: 0, successes: 0, lastUsed: 0 });\r\n    });\r\n\r\n    // Get active proxies (not too many failures)\r\n    const getActiveProxies = (): string[] => {\r\n        return proxies.filter(p => {\r\n            const s = stats.get(p);\r\n            // Filter out proxies with 5+ consecutive failures\r\n            return !s || s.failures < 5;\r\n        });\r\n    };\r\n\r\n    return {\r\n        /**\r\n         * Get next proxy in rotation (round-robin)\r\n         */\r\n        getNext(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            currentIndex = (currentIndex + 1) % active.length;\r\n            const proxy = active[currentIndex];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get a random proxy (good for avoiding patterns)\r\n         */\r\n        getRandom(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            const proxy = active[Math.floor(Math.random() * active.length)];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get all proxies\r\n         */\r\n        getAll(): string[] {\r\n            return [...proxies];\r\n        },\r\n\r\n        /**\r\n         * Get number of active proxies\r\n         */\r\n        size(): number {\r\n            return getActiveProxies().length;\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as failed\r\n         */\r\n        markFailed(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.failures++;\r\n                s.successes = 0; // Reset success count on failure\r\n                console.log(`Proxy marked failed (${s.failures}x): ${proxy.replace(/:.*@/, ':***@')}`);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as successful\r\n         */\r\n        markSuccess(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.successes++;\r\n                s.failures = 0; // Reset failure count on success\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Get a single proxy or create a pool from the input\r\n * Returns either a single proxy string or a ProxyPool\r\n */\r\nexport function getProxyOrPool(httpProxy: string | null | undefined): string | ProxyPool | undefined {\r\n    if (!httpProxy) return undefined;\r\n\r\n    const proxies = parseProxyList(httpProxy);\r\n\r\n    if (proxies.length === 0) {\r\n        return undefined;\r\n    } else if (proxies.length === 1) {\r\n        return proxies[0];\r\n    } else {\r\n        return createProxyPool(proxies);\r\n    }\r\n}\r\n\r\n/**\r\n * Get the next proxy from either a single proxy or a pool\r\n */\r\nexport function getNextProxy(proxyOrPool: string | ProxyPool | undefined): string | undefined {\r\n    if (!proxyOrPool) return undefined;\r\n\r\n    if (typeof proxyOrPool === 'string') {\r\n        return proxyOrPool;\r\n    }\r\n\r\n    return proxyOrPool.getRandom(); // Use random for better distribution\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1470, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/global-proxy.ts"],"sourcesContent":["// Global Proxy Pool - managed via admin panel, stored in database\r\nimport { parseProxyList, createProxyPool, ProxyPool } from './proxy-pool';\r\nimport { supabase } from './supabase';\r\n\r\nlet globalProxyPool: ProxyPool | null = null;\r\nlet proxyList: string[] = [];\r\nlet lastFetch = 0;\r\nconst CACHE_TTL = 60000; // Refresh every 60 seconds\r\n\r\n// Fetch proxies from database\r\nasync function fetchProxiesFromDB(): Promise<string[]> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        if (data?.value) {\r\n            return parseProxyList(data.value);\r\n        }\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error fetching from DB:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Initialize/refresh proxies\r\nasync function initGlobalProxies(force = false) {\r\n    const now = Date.now();\r\n\r\n    // Use cache if not expired\r\n    if (!force && now - lastFetch < CACHE_TTL && proxyList.length > 0) {\r\n        return;\r\n    }\r\n\r\n    proxyList = await fetchProxiesFromDB();\r\n    lastFetch = now;\r\n\r\n    if (proxyList.length > 1) {\r\n        globalProxyPool = createProxyPool(proxyList);\r\n        console.log(`[Global Proxy] Pool initialized with ${proxyList.length} proxies`);\r\n    } else if (proxyList.length === 1) {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] Using single proxy`);\r\n    } else {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] No proxies configured`);\r\n    }\r\n}\r\n\r\n// Get next proxy from global pool\r\nexport async function getGlobalProxy(): Promise<string | undefined> {\r\n    await initGlobalProxies();\r\n\r\n    if (globalProxyPool) {\r\n        return globalProxyPool.getNext();\r\n    }\r\n\r\n    return proxyList[0] || undefined;\r\n}\r\n\r\n// Get proxy count\r\nexport async function getGlobalProxyCount(): Promise<number> {\r\n    await initGlobalProxies();\r\n    return proxyList.length;\r\n}\r\n\r\n// Force refresh proxies (call after admin updates)\r\nexport async function refreshGlobalProxies(): Promise<void> {\r\n    await initGlobalProxies(true);\r\n}\r\n\r\n// Save proxies to database (admin only)\r\nexport async function saveGlobalProxies(proxies: string): Promise<boolean> {\r\n    try {\r\n        const { error } = await supabase\r\n            .from('app_settings')\r\n            .upsert({\r\n                key: 'proxy_list',\r\n                value: proxies,\r\n                updated_at: new Date().toISOString()\r\n            }, { onConflict: 'key' });\r\n\r\n        if (error) {\r\n            console.error('[Global Proxy] Error saving:', error);\r\n            return false;\r\n        }\r\n\r\n        // Refresh cache\r\n        await refreshGlobalProxies();\r\n        return true;\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error saving:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n// Get raw proxy list (for admin display)\r\nexport async function getGlobalProxyList(): Promise<string> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        return data?.value || '';\r\n    } catch {\r\n        return '';\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA,kEAAkE;AAClE;AACA;;;AAEA,IAAI,kBAAoC;AACxC,IAAI,YAAsB,EAAE;AAC5B,IAAI,YAAY;AAChB,MAAM,YAAY,OAAO,2BAA2B;AAEpD,8BAA8B;AAC9B,eAAe;IACX,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,IAAI,MAAM,OAAO;YACb,OAAO,IAAA,+IAAc,EAAC,KAAK,KAAK;QACpC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,0CAA0C;IAC5D;IACA,OAAO,EAAE;AACb;AAEA,6BAA6B;AAC7B,eAAe,kBAAkB,QAAQ,KAAK;IAC1C,MAAM,MAAM,KAAK,GAAG;IAEpB,2BAA2B;IAC3B,IAAI,CAAC,SAAS,MAAM,YAAY,aAAa,UAAU,MAAM,GAAG,GAAG;QAC/D;IACJ;IAEA,YAAY,MAAM;IAClB,YAAY;IAEZ,IAAI,UAAU,MAAM,GAAG,GAAG;QACtB,kBAAkB,IAAA,gJAAe,EAAC;QAClC,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,UAAU,MAAM,CAAC,QAAQ,CAAC;IAClF,OAAO,IAAI,UAAU,MAAM,KAAK,GAAG;QAC/B,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,iCAAiC,CAAC;IACnD,OAAO;QACH,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,oCAAoC,CAAC;IACtD;AACJ;AAGO,eAAe;IAClB,MAAM;IAEN,IAAI,iBAAiB;QACjB,OAAO,gBAAgB,OAAO;IAClC;IAEA,OAAO,SAAS,CAAC,EAAE,IAAI;AAC3B;AAGO,eAAe;IAClB,MAAM;IACN,OAAO,UAAU,MAAM;AAC3B;AAGO,eAAe;IAClB,MAAM,kBAAkB;AAC5B;AAGO,eAAe,kBAAkB,OAAe;IACnD,IAAI;QACA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CAC3B,IAAI,CAAC,gBACL,MAAM,CAAC;YACJ,KAAK;YACL,OAAO;YACP,YAAY,IAAI,OAAO,WAAW;QACtC,GAAG;YAAE,YAAY;QAAM;QAE3B,IAAI,OAAO;YACP,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,OAAO;QACX;QAEA,gBAAgB;QAChB,MAAM;QACN,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;IACX;AACJ;AAGO,eAAe;IAClB,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,OAAO,MAAM,SAAS;IAC1B,EAAE,OAAM;QACJ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 1570, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/analytics-service.ts"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\ninterface DailyStats {\r\n    requests_fetched: number;\r\n    bots_detected: number;\r\n    requests_accepted: number;\r\n    requests_declined: number;\r\n    users_blocked: number;\r\n    friends_removed: number;\r\n}\r\n\r\n/**\r\n * Get today's date string in YYYY-MM-DD format\r\n */\r\nfunction getTodayDate(): string {\r\n    return new Date().toISOString().split('T')[0];\r\n}\r\n\r\n/**\r\n * Increment a daily stat counter\r\n */\r\nexport async function incrementStat(\r\n    userId: string,\r\n    accountId: string,\r\n    stat: keyof DailyStats,\r\n    amount: number = 1\r\n): Promise<boolean> {\r\n    const today = getTodayDate();\r\n\r\n    // First try to get existing record\r\n    const { data: existing } = await supabase\r\n        .from('analytics_daily')\r\n        .select('*')\r\n        .eq('roblox_account_id', accountId)\r\n        .eq('date', today)\r\n        .single();\r\n\r\n    if (existing) {\r\n        // Update existing record - cast to access dynamic property\r\n        const currentValue = (existing as Record<string, number>)[stat] || 0;\r\n        const { error } = await supabase\r\n            .from('analytics_daily')\r\n            .update({ [stat]: currentValue + amount })\r\n            .eq('id', (existing as { id: string }).id);\r\n\r\n        return !error;\r\n    } else {\r\n        // Insert new record\r\n        const { error } = await supabase\r\n            .from('analytics_daily')\r\n            .insert({\r\n                user_id: userId,\r\n                roblox_account_id: accountId,\r\n                date: today,\r\n                [stat]: amount\r\n            });\r\n\r\n        return !error;\r\n    }\r\n}\r\n\r\n/**\r\n * Get stats for a specific date range\r\n */\r\nexport async function getStats(\r\n    accountId: string,\r\n    days: number = 7\r\n): Promise<Array<{\r\n    date: string;\r\n    stats: DailyStats;\r\n}>> {\r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n\r\n    const { data, error } = await supabase\r\n        .from('analytics_daily')\r\n        .select('*')\r\n        .eq('roblox_account_id', accountId)\r\n        .gte('date', startDate.toISOString().split('T')[0])\r\n        .order('date', { ascending: false });\r\n\r\n    if (error || !data) {\r\n        console.error('Failed to get stats:', error);\r\n        return [];\r\n    }\r\n\r\n    return data.map(row => ({\r\n        date: row.date,\r\n        stats: {\r\n            requests_fetched: row.requests_fetched || 0,\r\n            bots_detected: row.bots_detected || 0,\r\n            requests_accepted: row.requests_accepted || 0,\r\n            requests_declined: row.requests_declined || 0,\r\n            users_blocked: row.users_blocked || 0,\r\n            friends_removed: row.friends_removed || 0\r\n        }\r\n    }));\r\n}\r\n\r\n/**\r\n * Get total stats for an account\r\n */\r\nexport async function getTotalStats(accountId: string): Promise<DailyStats> {\r\n    const { data, error } = await supabase\r\n        .from('analytics_daily')\r\n        .select('*')\r\n        .eq('roblox_account_id', accountId);\r\n\r\n    if (error || !data || data.length === 0) {\r\n        return {\r\n            requests_fetched: 0,\r\n            bots_detected: 0,\r\n            requests_accepted: 0,\r\n            requests_declined: 0,\r\n            users_blocked: 0,\r\n            friends_removed: 0\r\n        };\r\n    }\r\n\r\n    return {\r\n        requests_fetched: data.reduce((sum, r) => sum + (r.requests_fetched || 0), 0),\r\n        bots_detected: data.reduce((sum, r) => sum + (r.bots_detected || 0), 0),\r\n        requests_accepted: data.reduce((sum, r) => sum + (r.requests_accepted || 0), 0),\r\n        requests_declined: data.reduce((sum, r) => sum + (r.requests_declined || 0), 0),\r\n        users_blocked: data.reduce((sum, r) => sum + (r.users_blocked || 0), 0),\r\n        friends_removed: data.reduce((sum, r) => sum + (r.friends_removed || 0), 0)\r\n    };\r\n}\r\n\r\n/**\r\n * Get stats for all accounts of a user\r\n */\r\nexport async function getUserStats(userId: string, days: number = 30): Promise<DailyStats> {\r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n\r\n    const { data, error } = await supabase\r\n        .from('analytics_daily')\r\n        .select('*')\r\n        .eq('user_id', userId)\r\n        .gte('date', startDate.toISOString().split('T')[0]);\r\n\r\n    if (error || !data || data.length === 0) {\r\n        return {\r\n            requests_fetched: 0,\r\n            bots_detected: 0,\r\n            requests_accepted: 0,\r\n            requests_declined: 0,\r\n            users_blocked: 0,\r\n            friends_removed: 0\r\n        };\r\n    }\r\n\r\n    return {\r\n        requests_fetched: data.reduce((sum, r) => sum + (r.requests_fetched || 0), 0),\r\n        bots_detected: data.reduce((sum, r) => sum + (r.bots_detected || 0), 0),\r\n        requests_accepted: data.reduce((sum, r) => sum + (r.requests_accepted || 0), 0),\r\n        requests_declined: data.reduce((sum, r) => sum + (r.requests_declined || 0), 0),\r\n        users_blocked: data.reduce((sum, r) => sum + (r.users_blocked || 0), 0),\r\n        friends_removed: data.reduce((sum, r) => sum + (r.friends_removed || 0), 0)\r\n    };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1679, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/app/api/filter/requests/route.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport { getCurrentUser } from '@/lib/auth';\r\nimport { getFriendRequests, getUserInfo, getCSRFToken, getAvatarUrl } from '@/lib/roblox';\r\nimport { detectBot } from '@/lib/bot-detector';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { getGlobalProxy, getGlobalProxyCount } from '@/lib/global-proxy';\r\nimport { sleep } from '@/lib/rate-limiter';\r\nimport { incrementStat } from '@/lib/analytics-service';\r\n\r\ninterface EnrichedRequest {\r\n    id: number;\r\n    username: string;\r\n    displayName: string;\r\n    avatarUrl: string;\r\n    created: string | null;\r\n    isBanned: boolean;\r\n    isBot: boolean;\r\n    botScore: number;\r\n    botReason: string | null;\r\n}\r\n\r\nexport async function GET(request: NextRequest) {\r\n    const encoder = new TextEncoder();\r\n\r\n    const stream = new ReadableStream({\r\n        async start(controller) {\r\n            const sendEvent = (type: string, data: unknown) => {\r\n                controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type, ...data as object })}\\n\\n`));\r\n            };\r\n\r\n            try {\r\n                const user = await getCurrentUser();\r\n\r\n                if (!user) {\r\n                    sendEvent('error', { message: 'Not authenticated' });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                const { searchParams } = new URL(request.url);\r\n                const accountId = searchParams.get('accountId');\r\n\r\n                let cookie: string | null = null;\r\n                let accountName: string | null = null;\r\n\r\n                if (accountId) {\r\n                    const { data: account } = await supabase\r\n                        .from('roblox_accounts')\r\n                        .select('cookie, account_name')\r\n                        .eq('id', accountId)\r\n                        .eq('user_id', user.id)\r\n                        .single();\r\n\r\n                    if (!account) {\r\n                        sendEvent('error', { message: 'Account not found' });\r\n                        controller.close();\r\n                        return;\r\n                    }\r\n\r\n                    cookie = account.cookie;\r\n                    accountName = account.account_name;\r\n\r\n                    await supabase\r\n                        .from('roblox_accounts')\r\n                        .update({ last_used: new Date().toISOString() })\r\n                        .eq('id', accountId);\r\n                } else {\r\n                    cookie = user.roblox_cookie;\r\n                }\r\n\r\n                if (!cookie) {\r\n                    sendEvent('error', { message: 'No Roblox account configured' });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                // Use global proxy pool (from admin settings)\r\n                const proxyCount = await getGlobalProxyCount();\r\n\r\n                sendEvent('progress', {\r\n                    phase: 'Fetching friend requests...',\r\n                    percent: 0,\r\n                    real: 0,\r\n                    fake: 0\r\n                });\r\n\r\n                const csrfToken = await getCSRFToken(cookie, await getGlobalProxy());\r\n                const requests = await getFriendRequests(cookie, await getGlobalProxy());\r\n\r\n                sendEvent('progress', {\r\n                    phase: `Found ${requests.length} requests`,\r\n                    percent: 5,\r\n                    real: 0,\r\n                    fake: 0\r\n                });\r\n\r\n                if (requests.length === 0) {\r\n                    sendEvent('complete', {\r\n                        csrfToken,\r\n                        accountName,\r\n                        proxyCount,\r\n                        requests: [],\r\n                        total: 0,\r\n                        bots: 0,\r\n                        safe: 0,\r\n                    });\r\n                    controller.close();\r\n                    return;\r\n                }\r\n\r\n                // Process with live counters\r\n                const enrichedRequests: EnrichedRequest[] = [];\r\n                let realCount = 0;\r\n                let fakeCount = 0;\r\n\r\n                const batchSize = proxyCount > 10 ? 20 : proxyCount > 1 ? 10 : 5;\r\n                const delayBetweenBatches = proxyCount > 10 ? 300 : proxyCount > 1 ? 500 : 1000;\r\n\r\n                for (let i = 0; i < requests.length; i += batchSize) {\r\n                    const batch = requests.slice(i, i + batchSize);\r\n\r\n                    const batchResults = await Promise.all(\r\n                        batch.map(async (req) => {\r\n                            const proxy = await getGlobalProxy();\r\n                            const userInfo = await getUserInfo(req.id, proxy);\r\n                            const username = userInfo?.name || `User_${req.id}`;\r\n                            const detection = await detectBot(req.id, username, userInfo);\r\n\r\n                            return {\r\n                                id: req.id,\r\n                                username,\r\n                                displayName: userInfo?.displayName || username,\r\n                                avatarUrl: getAvatarUrl(req.id),\r\n                                created: userInfo?.created || null,\r\n                                isBanned: userInfo?.isBanned || false,\r\n                                isBot: detection.isBot,\r\n                                botScore: detection.score,\r\n                                botReason: detection.reason,\r\n                            };\r\n                        })\r\n                    );\r\n\r\n                    // Update counts\r\n                    batchResults.forEach(r => {\r\n                        if (r.isBot) fakeCount++;\r\n                        else realCount++;\r\n                    });\r\n\r\n                    enrichedRequests.push(...batchResults);\r\n\r\n                    const processed = Math.min(i + batchSize, requests.length);\r\n                    const percent = 5 + Math.round((processed / requests.length) * 93);\r\n\r\n                    // Send live counter update\r\n                    sendEvent('progress', {\r\n                        phase: `Scanning... ${processed}/${requests.length}`,\r\n                        percent,\r\n                        real: realCount,\r\n                        fake: fakeCount,\r\n                        processed,\r\n                        total: requests.length\r\n                    });\r\n\r\n                    if (i + batchSize < requests.length) {\r\n                        await sleep(delayBetweenBatches);\r\n                    }\r\n                }\r\n\r\n                // Save friend requests to Supabase (normalized friend_requests table)\r\n                if (accountId) {\r\n                    const { saveFriendRequests } = await import('@/lib/friend-request-service');\r\n                    await saveFriendRequests(accountId, enrichedRequests.map(r => ({\r\n                        id: r.id,\r\n                        username: r.username,\r\n                        displayName: r.displayName,\r\n                        avatarUrl: r.avatarUrl,\r\n                        created: r.created,\r\n                        isBanned: r.isBanned,\r\n                        isBot: r.isBot,\r\n                        botScore: r.botScore,\r\n                        botReason: r.botReason\r\n                    })));\r\n\r\n                    // Update analytics\r\n                    await incrementStat(user.id, accountId, 'requests_fetched', enrichedRequests.length);\r\n                    await incrementStat(user.id, accountId, 'bots_detected', fakeCount);\r\n                }\r\n\r\n                sendEvent('complete', {\r\n                    csrfToken,\r\n                    accountName,\r\n                    proxyCount,\r\n                    requests: enrichedRequests,\r\n                    total: enrichedRequests.length,\r\n                    bots: fakeCount,\r\n                    safe: realCount,\r\n                });\r\n\r\n                controller.close();\r\n            } catch (error) {\r\n                console.error('Error fetching requests:', error);\r\n                sendEvent('error', { message: 'Failed to fetch friend requests' });\r\n                controller.close();\r\n            }\r\n        }\r\n    });\r\n\r\n    return new Response(stream, {\r\n        headers: {\r\n            'Content-Type': 'text/event-stream',\r\n            'Cache-Control': 'no-cache',\r\n            'Connection': 'keep-alive',\r\n        },\r\n    });\r\n}\r\n"],"names":[],"mappings":"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"}}]
}