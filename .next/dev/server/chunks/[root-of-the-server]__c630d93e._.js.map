{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AACN,MAAM;AAEC,MAAM,WAAW,IAAA,gMAAY,EAAC,aAAa"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\nimport { cookies } from 'next/headers';\r\nimport { supabase } from './supabase';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET || 'fallback-secret');\r\n\r\nexport interface JWTPayload {\r\n    userId: string;\r\n    discordId: string;\r\n    isAdmin: boolean;\r\n}\r\n\r\nexport async function createSession(userId: string, discordId: string, isAdmin: boolean, ip?: string, userAgent?: string) {\r\n    const token = await new SignJWT({ userId, discordId, isAdmin })\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setExpirationTime('7d')\r\n        .sign(JWT_SECRET);\r\n\r\n    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();\r\n\r\n    await supabase.from('sessions').insert({\r\n        user_id: userId,\r\n        token,\r\n        ip,\r\n        user_agent: userAgent,\r\n        expires_at: expiresAt,\r\n    });\r\n\r\n    return token;\r\n}\r\n\r\nexport async function verifySession(token: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n\r\n        console.log('verifySession - JWT payload:', payload);\r\n\r\n        // Simple query without join\r\n        const { data: session, error: sessionError } = await supabase\r\n            .from('sessions')\r\n            .select('*')\r\n            .eq('token', token)\r\n            .single();\r\n\r\n        if (sessionError) {\r\n            console.error('verifySession - Session query error:', sessionError);\r\n            return null;\r\n        }\r\n\r\n        if (!session || new Date(session.expires_at) < new Date()) {\r\n            console.log('verifySession - Session expired or not found');\r\n            return null;\r\n        }\r\n\r\n        // Get user separately\r\n        const { data: user, error: userError } = await supabase\r\n            .from('users')\r\n            .select('*')\r\n            .eq('id', session.user_id)\r\n            .single();\r\n\r\n        if (userError || !user) {\r\n            console.error('verifySession - User query error:', userError);\r\n            return null;\r\n        }\r\n\r\n        console.log('verifySession - Success, user:', user.username);\r\n\r\n        return {\r\n            userId: session.user_id,\r\n            discordId: user.discord_id,\r\n            isAdmin: user.is_admin,\r\n        };\r\n    } catch (error) {\r\n        console.error('verifySession - JWT or other error:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getCurrentUser() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('session')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    const payload = await verifySession(token);\r\n    if (!payload) return null;\r\n\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', payload.userId)\r\n        .single();\r\n\r\n    return user;\r\n}\r\n\r\nexport async function isUserAuthorized(userId: string): Promise<boolean> {\r\n    const { data: user } = await supabase\r\n        .from('users')\r\n        .select('*')\r\n        .eq('id', userId)\r\n        .single();\r\n\r\n    if (!user) return false;\r\n    if (user.is_admin) return true;\r\n    if (!user.is_authorized) return false;\r\n    if (user.auth_expiry && new Date(user.auth_expiry) < new Date()) return false;\r\n\r\n    return true;\r\n}\r\n\r\nexport function getDiscordOAuthUrl() {\r\n    const params = new URLSearchParams({\r\n        client_id: process.env.DISCORD_CLIENT_ID!,\r\n        redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        response_type: 'code',\r\n        scope: 'identify email',\r\n    });\r\n\r\n    return `https://discord.com/api/oauth2/authorize?${params.toString()}`;\r\n}\r\n\r\nexport async function exchangeCodeForToken(code: string) {\r\n    const response = await fetch('https://discord.com/api/oauth2/token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded',\r\n        },\r\n        body: new URLSearchParams({\r\n            client_id: process.env.DISCORD_CLIENT_ID!,\r\n            client_secret: process.env.DISCORD_CLIENT_SECRET!,\r\n            grant_type: 'authorization_code',\r\n            code,\r\n            redirect_uri: process.env.DISCORD_REDIRECT_URI!,\r\n        }),\r\n    });\r\n\r\n    return response.json();\r\n}\r\n\r\nexport async function getDiscordUser(accessToken: string) {\r\n    const response = await fetch('https://discord.com/api/users/@me', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        },\r\n    });\r\n\r\n    return response.json();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/proxy-pool.ts"],"sourcesContent":["// Proxy Pool - Manages multiple proxies with rotation\r\n\r\nexport interface ProxyPool {\r\n    getNext(): string | undefined;\r\n    getRandom(): string | undefined;\r\n    getAll(): string[];\r\n    size(): number;\r\n    markFailed(proxy: string): void;\r\n    markSuccess(proxy: string): void;\r\n}\r\n\r\ninterface ProxyStats {\r\n    failures: number;\r\n    successes: number;\r\n    lastUsed: number;\r\n}\r\n\r\n/**\r\n * Parse proxy list from various formats\r\n * Supports: newline-separated, comma-separated, JSON array\r\n */\r\nexport function parseProxyList(input: string | null | undefined): string[] {\r\n    if (!input || typeof input !== 'string') {\r\n        return [];\r\n    }\r\n\r\n    const trimmed = input.trim();\r\n\r\n    // Try JSON array first\r\n    if (trimmed.startsWith('[')) {\r\n        try {\r\n            const parsed = JSON.parse(trimmed);\r\n            if (Array.isArray(parsed)) {\r\n                return parsed.filter(p => typeof p === 'string' && p.trim()).map(p => p.trim());\r\n            }\r\n        } catch {\r\n            // Not valid JSON, continue\r\n        }\r\n    }\r\n\r\n    // Split by newlines or commas\r\n    const proxies = trimmed\r\n        .split(/[\\n,]+/)\r\n        .map(p => p.trim())\r\n        .filter(p => p.length > 0 && (p.startsWith('http://') || p.startsWith('https://') || p.includes('@')));\r\n\r\n    return proxies;\r\n}\r\n\r\n/**\r\n * Create a proxy pool with rotation and failure tracking\r\n */\r\nexport function createProxyPool(proxies: string[]): ProxyPool {\r\n    const stats = new Map<string, ProxyStats>();\r\n    let currentIndex = 0;\r\n\r\n    // Initialize stats for all proxies\r\n    proxies.forEach(proxy => {\r\n        stats.set(proxy, { failures: 0, successes: 0, lastUsed: 0 });\r\n    });\r\n\r\n    // Get active proxies (not too many failures)\r\n    const getActiveProxies = (): string[] => {\r\n        return proxies.filter(p => {\r\n            const s = stats.get(p);\r\n            // Filter out proxies with 5+ consecutive failures\r\n            return !s || s.failures < 5;\r\n        });\r\n    };\r\n\r\n    return {\r\n        /**\r\n         * Get next proxy in rotation (round-robin)\r\n         */\r\n        getNext(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            currentIndex = (currentIndex + 1) % active.length;\r\n            const proxy = active[currentIndex];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get a random proxy (good for avoiding patterns)\r\n         */\r\n        getRandom(): string | undefined {\r\n            const active = getActiveProxies();\r\n            if (active.length === 0) return undefined;\r\n\r\n            const proxy = active[Math.floor(Math.random() * active.length)];\r\n\r\n            const s = stats.get(proxy);\r\n            if (s) s.lastUsed = Date.now();\r\n\r\n            return proxy;\r\n        },\r\n\r\n        /**\r\n         * Get all proxies\r\n         */\r\n        getAll(): string[] {\r\n            return [...proxies];\r\n        },\r\n\r\n        /**\r\n         * Get number of active proxies\r\n         */\r\n        size(): number {\r\n            return getActiveProxies().length;\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as failed\r\n         */\r\n        markFailed(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.failures++;\r\n                s.successes = 0; // Reset success count on failure\r\n                console.log(`Proxy marked failed (${s.failures}x): ${proxy.replace(/:.*@/, ':***@')}`);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mark a proxy as successful\r\n         */\r\n        markSuccess(proxy: string): void {\r\n            const s = stats.get(proxy);\r\n            if (s) {\r\n                s.successes++;\r\n                s.failures = 0; // Reset failure count on success\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Get a single proxy or create a pool from the input\r\n * Returns either a single proxy string or a ProxyPool\r\n */\r\nexport function getProxyOrPool(httpProxy: string | null | undefined): string | ProxyPool | undefined {\r\n    if (!httpProxy) return undefined;\r\n\r\n    const proxies = parseProxyList(httpProxy);\r\n\r\n    if (proxies.length === 0) {\r\n        return undefined;\r\n    } else if (proxies.length === 1) {\r\n        return proxies[0];\r\n    } else {\r\n        return createProxyPool(proxies);\r\n    }\r\n}\r\n\r\n/**\r\n * Get the next proxy from either a single proxy or a pool\r\n */\r\nexport function getNextProxy(proxyOrPool: string | ProxyPool | undefined): string | undefined {\r\n    if (!proxyOrPool) return undefined;\r\n\r\n    if (typeof proxyOrPool === 'string') {\r\n        return proxyOrPool;\r\n    }\r\n\r\n    return proxyOrPool.getRandom(); // Use random for better distribution\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/lib/global-proxy.ts"],"sourcesContent":["// Global Proxy Pool - managed via admin panel, stored in database\r\nimport { parseProxyList, createProxyPool, ProxyPool } from './proxy-pool';\r\nimport { supabase } from './supabase';\r\n\r\nlet globalProxyPool: ProxyPool | null = null;\r\nlet proxyList: string[] = [];\r\nlet lastFetch = 0;\r\nconst CACHE_TTL = 60000; // Refresh every 60 seconds\r\n\r\n// Fetch proxies from database\r\nasync function fetchProxiesFromDB(): Promise<string[]> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        if (data?.value) {\r\n            return parseProxyList(data.value);\r\n        }\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error fetching from DB:', error);\r\n    }\r\n    return [];\r\n}\r\n\r\n// Initialize/refresh proxies\r\nasync function initGlobalProxies(force = false) {\r\n    const now = Date.now();\r\n\r\n    // Use cache if not expired\r\n    if (!force && now - lastFetch < CACHE_TTL && proxyList.length > 0) {\r\n        return;\r\n    }\r\n\r\n    proxyList = await fetchProxiesFromDB();\r\n    lastFetch = now;\r\n\r\n    if (proxyList.length > 1) {\r\n        globalProxyPool = createProxyPool(proxyList);\r\n        console.log(`[Global Proxy] Pool initialized with ${proxyList.length} proxies`);\r\n    } else if (proxyList.length === 1) {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] Using single proxy`);\r\n    } else {\r\n        globalProxyPool = null;\r\n        console.log(`[Global Proxy] No proxies configured`);\r\n    }\r\n}\r\n\r\n// Get next proxy from global pool\r\nexport async function getGlobalProxy(): Promise<string | undefined> {\r\n    await initGlobalProxies();\r\n\r\n    if (globalProxyPool) {\r\n        return globalProxyPool.getNext();\r\n    }\r\n\r\n    return proxyList[0] || undefined;\r\n}\r\n\r\n// Get proxy count\r\nexport async function getGlobalProxyCount(): Promise<number> {\r\n    await initGlobalProxies();\r\n    return proxyList.length;\r\n}\r\n\r\n// Force refresh proxies (call after admin updates)\r\nexport async function refreshGlobalProxies(): Promise<void> {\r\n    await initGlobalProxies(true);\r\n}\r\n\r\n// Save proxies to database (admin only)\r\nexport async function saveGlobalProxies(proxies: string): Promise<boolean> {\r\n    try {\r\n        const { error } = await supabase\r\n            .from('app_settings')\r\n            .upsert({\r\n                key: 'proxy_list',\r\n                value: proxies,\r\n                updated_at: new Date().toISOString()\r\n            }, { onConflict: 'key' });\r\n\r\n        if (error) {\r\n            console.error('[Global Proxy] Error saving:', error);\r\n            return false;\r\n        }\r\n\r\n        // Refresh cache\r\n        await refreshGlobalProxies();\r\n        return true;\r\n    } catch (error) {\r\n        console.error('[Global Proxy] Error saving:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n// Get raw proxy list (for admin display)\r\nexport async function getGlobalProxyList(): Promise<string> {\r\n    try {\r\n        const { data } = await supabase\r\n            .from('app_settings')\r\n            .select('value')\r\n            .eq('key', 'proxy_list')\r\n            .single();\r\n\r\n        return data?.value || '';\r\n    } catch {\r\n        return '';\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA,kEAAkE;AAClE;AACA;;;AAEA,IAAI,kBAAoC;AACxC,IAAI,YAAsB,EAAE;AAC5B,IAAI,YAAY;AAChB,MAAM,YAAY,OAAO,2BAA2B;AAEpD,8BAA8B;AAC9B,eAAe;IACX,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,IAAI,MAAM,OAAO;YACb,OAAO,IAAA,+IAAc,EAAC,KAAK,KAAK;QACpC;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,0CAA0C;IAC5D;IACA,OAAO,EAAE;AACb;AAEA,6BAA6B;AAC7B,eAAe,kBAAkB,QAAQ,KAAK;IAC1C,MAAM,MAAM,KAAK,GAAG;IAEpB,2BAA2B;IAC3B,IAAI,CAAC,SAAS,MAAM,YAAY,aAAa,UAAU,MAAM,GAAG,GAAG;QAC/D;IACJ;IAEA,YAAY,MAAM;IAClB,YAAY;IAEZ,IAAI,UAAU,MAAM,GAAG,GAAG;QACtB,kBAAkB,IAAA,gJAAe,EAAC;QAClC,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,UAAU,MAAM,CAAC,QAAQ,CAAC;IAClF,OAAO,IAAI,UAAU,MAAM,KAAK,GAAG;QAC/B,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,iCAAiC,CAAC;IACnD,OAAO;QACH,kBAAkB;QAClB,QAAQ,GAAG,CAAC,CAAC,oCAAoC,CAAC;IACtD;AACJ;AAGO,eAAe;IAClB,MAAM;IAEN,IAAI,iBAAiB;QACjB,OAAO,gBAAgB,OAAO;IAClC;IAEA,OAAO,SAAS,CAAC,EAAE,IAAI;AAC3B;AAGO,eAAe;IAClB,MAAM;IACN,OAAO,UAAU,MAAM;AAC3B;AAGO,eAAe;IAClB,MAAM,kBAAkB;AAC5B;AAGO,eAAe,kBAAkB,OAAe;IACnD,IAAI;QACA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,oIAAQ,CAC3B,IAAI,CAAC,gBACL,MAAM,CAAC;YACJ,KAAK;YACL,OAAO;YACP,YAAY,IAAI,OAAO,WAAW;QACtC,GAAG;YAAE,YAAY;QAAM;QAE3B,IAAI,OAAO;YACP,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,OAAO;QACX;QAEA,gBAAgB;QAChB,MAAM;QACN,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;IACX;AACJ;AAGO,eAAe;IAClB,IAAI;QACA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,oIAAQ,CAC1B,IAAI,CAAC,gBACL,MAAM,CAAC,SACP,EAAE,CAAC,OAAO,cACV,MAAM;QAEX,OAAO,MAAM,SAAS;IAC1B,EAAE,OAAM;QACJ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/stashy/Desktop/Projects/Trend/src/app/api/admin/settings/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getCurrentUser } from '@/lib/auth';\r\nimport { getGlobalProxyList, saveGlobalProxies } from '@/lib/global-proxy';\r\nimport { parseProxyList } from '@/lib/proxy-pool';\r\n\r\n// GET - Get current settings\r\nexport async function GET() {\r\n    try {\r\n        const user = await getCurrentUser();\r\n\r\n        if (!user || !user.is_admin) {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });\r\n        }\r\n\r\n        const proxyList = await getGlobalProxyList();\r\n        const proxyCount = parseProxyList(proxyList).length;\r\n\r\n        return NextResponse.json({\r\n            proxies: proxyList,\r\n            proxyCount,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error getting settings:', error);\r\n        return NextResponse.json({ error: 'Failed to get settings' }, { status: 500 });\r\n    }\r\n}\r\n\r\n// POST - Update settings\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n\r\n        if (!user || !user.is_admin) {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });\r\n        }\r\n\r\n        const body = await request.json();\r\n\r\n        if (body.proxies !== undefined) {\r\n            const success = await saveGlobalProxies(body.proxies);\r\n            if (!success) {\r\n                return NextResponse.json({ error: 'Failed to save proxies' }, { status: 500 });\r\n            }\r\n        }\r\n\r\n        const proxyList = await getGlobalProxyList();\r\n        const proxyCount = parseProxyList(proxyList).length;\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            proxies: proxyList,\r\n            proxyCount,\r\n        });\r\n    } catch (error) {\r\n        console.error('Error updating settings:', error);\r\n        return NextResponse.json({ error: 'Failed to update settings' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAGO,eAAe;IAClB,IAAI;QACA,MAAM,OAAO,MAAM,IAAA,sIAAc;QAEjC,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YACzB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,YAAY,MAAM,IAAA,qJAAkB;QAC1C,MAAM,aAAa,IAAA,+IAAc,EAAC,WAAW,MAAM;QAEnD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT;QACJ;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAChF;AACJ;AAGO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,OAAO,MAAM,IAAA,sIAAc;QAEjC,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YACzB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,IAAI,KAAK,OAAO,KAAK,WAAW;YAC5B,MAAM,UAAU,MAAM,IAAA,oJAAiB,EAAC,KAAK,OAAO;YACpD,IAAI,CAAC,SAAS;gBACV,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAAyB,GAAG;oBAAE,QAAQ;gBAAI;YAChF;QACJ;QAEA,MAAM,YAAY,MAAM,IAAA,qJAAkB;QAC1C,MAAM,aAAa,IAAA,+IAAc,EAAC,WAAW,MAAM;QAEnD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,SAAS;YACT;QACJ;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA4B,GAAG;YAAE,QAAQ;QAAI;IACnF;AACJ"}}]
}